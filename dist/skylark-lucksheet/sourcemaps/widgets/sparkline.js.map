{"version":3,"sources":["widgets/sparkline.js"],"names":["define","Store","createClass","Class","args","this","init","apply","arguments","length","prototype","$","extend","_super","Array","slice","call","unshift","cls","SPFormat","fre","precre","format","fclass","render","fieldset","lookups","options","match","token","lookupkey","fieldvalue","prec","self","fields","replace","lookup","exec","undefined","get","isNumber","formatNumber","spformat","clipval","val","min","max","quartile","values","q","vl","Math","floor","normalizeValue","nf","parseFloat","normalizeValues","vals","i","result","all","arr","ignoreNull","remove","filter","push","num","isNaN","isFinite","groupsize","groupsep","decsep","p","toString","toFixed","split","inArray","splice","join","RangeMap","map","key","range","rangelist","hasOwnProperty","indexOf","Infinity","value","range_map","luckysheetSparkline","defaultOption","common","type","lineColor","fillColor","defaultPixelsPerValue","width","height","composite","tagValuesAttribute","tagOptionsPrefix","enableTagOptions","enableHighlight","highlightLighten","tooltipSkipNull","tooltipPrefix","tooltipSuffix","disableHiddenCheck","numberFormatter","numberDigitGroupCount","numberDigitGroupSep","numberDecimalMark","disableTooltips","disableInteraction","offsetX","offsetY","line","spotColor","highlightSpotColor","highlightLineColor","spotRadius","minSpotColor","maxSpotColor","lineWidth","normalRangeMin","normalRangeMax","normalRangeColor","drawNormalOnTop","chartRangeMin","chartRangeMax","chartRangeMinX","chartRangeMaxX","bar","barColor","negBarColor","stackedBarColor","zeroColor","nullColor","zeroAxis","barWidth","barSpacing","chartRangeClip","colorMap","column","tristate","posBarColor","zeroBarColor","discrete","lineHeight","thresholdColor","thresholdValue","bullet","targetColor","targetWidth","performanceColor","rangeColors","base","pie","offset","sliceColors","borderWidth","borderColor","box","raw","boxLineColor","boxFillColor","whiskerColor","outlierLineColor","outlierFillColor","medianColor","showOutliers","outlierIQR","target","el","vertices","regionMap","xvalues","yvalues","yminmax","hightlightSpotId","lastShapeId","getRegion","x","y","getCurrentRegionFields","currentRegion","isNull","color","renderHighlight","highlightSpot","highlightLine","vertex","drawCircle","highlightSpotId","id","insertAfterShape","drawLine","canvasTop","canvasHeight","highlightLineId","removeHighlight","removeShapeId","scanValues","isStr","isArray","sp","valcount","Number","maxy","maxyorg","miny","minyorg","maxx","minx","processRangeOptions","drawNormalRange","canvasLeft","canvasWidth","rangey","ytop","round","drawRect","append","userValues","rangex","yvallast","path","paths","xnext","xpos","xposnext","last","next","yvalcount","lineShapes","fillShapes","plen","valueSpots","hlSpotsEnabled","mergedOptions","ceil","pop","drawShape","parseInt","isStackString","groupMin","groupMax","stackRanges","numValues","vlen","xaxisOffset","clipMin","clipMax","stacked","vlist","j","slen","svals","yoffset","stackMin","stackMax","regionShapes","totalBarWidth","stackTotals","stackRangesNeg","abs","canvasHeightEf","isNeg","colorMapByIndex","colorMapByValue","ensureArray","calcColor","stacknum","valuenum","newColor","renderRegion","highlight","yoffsetNeg","minPlotted","allMin","calcHighlightColor","halfHeight","interval","itemWidth","pheight","shapes","valueShapes","regiondata","disabled","shapeid","getShapeAt","fieldkey","substr","region","changeHighlight","shape","renderRange","renderPerformance","renderTarget","replaceWithShape","rn","rangeval","rangewidth","perfval","perfwidth","targetval","targettop","targetheight","p1","t0","total","radius","percent","newslice","renderSlice","start","end","circle","PI","drawPieSlice","field","quartiles","loutlier","routlier","lwhisker","rwhisker","iqr","q1","q2","q3","size","unitSize","minValue","maxValue","sort","a","b","shapeCount","shapeseq","userOptions","extendedOptions","defaults","pixelWidth","pixelHeight","_getContext","context","ctx","_canvasID","getContext","strokeStyle","fillStyle","reset","clearRect","currentTargetShapeId","_drawShape","beginPath","moveTo","lineTo","stroke","fill","targetX","targetY","isPointInPath","_drawCircle","arc","_drawPieSlice","startAngle","endAngle","closePath","_drawRect","appendShape","replaceWithShapes","shapeids","sid","first","shapemap","canvasid","x1","y1","x2","y2","_genShape","shapetype","shapeargs","barHighlightMixin","newShapes","newShape","ids","_luckysheetSparkLineOptions","_luckysheetSparkLineTarget","item"],"mappings":"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BC,iBAAiB,EACjBC,oBAAoB,EACpBC,QAAS,EACTC,QAAS,GAIbC,MACIC,UAAW,EACXC,mBAAoB,OACpBC,mBAAoB,OACpBC,WAAY,IACZC,aAAc,EACdC,aAAc,EACdC,UAAW,EACXC,oBAAgBtF,EAChBuF,oBAAgBvF,EAChBwF,iBAAkB,OAClBC,iBAAiB,EACjBC,mBAAe1F,EACf2F,mBAAe3F,EACf4F,oBAAgB5F,EAChB6F,oBAAgB7F,GAIpB8F,KACIC,SAAU,UACVC,YAAa,UACbC,iBACI,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEJC,eAAWlG,EACXmG,eAAWnG,EACXoG,UAAU,EACVC,SAAU,EACVC,WAAY,EACZX,mBAAe3F,EACf0F,mBAAe1F,EACfuG,gBAAgB,EAChBC,cAAUxG,GAGdyG,QACIV,SAAU,UACVC,YAAa,UACbC,iBACI,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEJC,eAAWlG,EACXmG,eAAWnG,EACXoG,UAAU,EACVC,SAAU,EACVC,WAAY,EACZX,mBAAe3F,EACf0F,mBAAe1F,EACfuG,gBAAgB,EAChBC,cAAUxG,GAId0G,UACIL,SAAU,EACVC,WAAY,EACZK,YAAa,UACbX,YAAa,UACbY,aAAc,OACdJ,aAKJK,UACIC,WAAY,OACZC,eAAgB,UAChBC,eAAgB,EAChBrB,mBAAe3F,EACf0F,mBAAe1F,EACfuG,gBAAgB,GAIpBU,QACIC,YAAa,OACbC,YAAa,EAEbC,iBAAkB,OAClBC,aACI,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEJC,UAAMtH,GAMVuH,KACIC,OAAQ,EACRC,aACI,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEJC,YAAa,EACbC,YAAa,QAIjBC,KACIC,KAAK,EACLC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","file":"../../widgets/sparkline.js","sourcesContent":["define([\n    '../store'\n], function (Store) {\n    'use strict';\n    //sparkline设置\n    let createClass = function ()\n        /* [baseclass, [mixin, ...]], definition */\n        {\n            let Class, args;\n            Class = function () {\n                this.init.apply(this, arguments);\n            };\n            if (arguments.length > 1) {\n                if (arguments[0]) {\n                    Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);\n                    Class._super = arguments[0].prototype;\n                } else {\n                    Class.prototype = arguments[arguments.length - 1];\n                }\n                if (arguments.length > 2) {\n                    args = Array.prototype.slice.call(arguments, 1, -1);\n                    args.unshift(Class.prototype);\n                    $.extend.apply($, args);\n                }\n            } else {\n                Class.prototype = arguments[0];\n            }\n            Class.prototype.cls = Class;\n            return Class;\n        };    \n    /**\n * Wraps a format string for tooltips\n * {{x}}\n * {{x.2}\n * {{x:months}}\n */\n    let SPFormat = createClass({\n        fre: /\\{\\{([\\w.]+?)(:(.+?))?\\}\\}/g,\n        precre: /(\\w+)\\.(\\d+)/,\n        init: function (format, fclass) {\n            this.format = format;\n            this.fclass = fclass;\n        },\n        render: function (fieldset, lookups, options) {\n            let self = this, fields = fieldset, match, token, lookupkey, fieldvalue, prec;\n            return this.format.replace(this.fre, function () {\n                let lookup;\n                token = arguments[1];\n                lookupkey = arguments[3];\n                match = self.precre.exec(token);\n                if (match) {\n                    prec = match[2];\n                    token = match[1];\n                } else {\n                    prec = false;\n                }\n                fieldvalue = fields[token];\n                if (fieldvalue === undefined) {\n                    return '';\n                }\n                if (lookupkey && lookups && lookups[lookupkey]) {\n                    lookup = lookups[lookupkey];\n                    if (lookup.get) {\n                        // RangeMap\n                        return lookups[lookupkey].get(fieldvalue) || fieldvalue;\n                    } else {\n                        return lookups[lookupkey][fieldvalue] || fieldvalue;\n                    }\n                }\n                if (isNumber(fieldvalue)) {\n                    if (options.get('numberFormatter')) {\n                        fieldvalue = options.get('numberFormatter')(fieldvalue);\n                    } else {\n                        fieldvalue = formatNumber(fieldvalue, prec, options.get('numberDigitGroupCount'), options.get('numberDigitGroupSep'), options.get('numberDecimalMark'));\n                    }\n                }\n                return fieldvalue;\n            });\n        }\n    });    // convience method to avoid needing the new operator\n    // convience method to avoid needing the new operator\n    $.spformat = function (format, fclass) {\n        return new SPFormat(format, fclass);\n    };\n    let clipval = function (val, min, max) {\n        if (val < min) {\n            return min;\n        }\n        if (val > max) {\n            return max;\n        }\n        return val;\n    };\n    let quartile = function (values, q) {\n        let vl;\n        if (q === 2) {\n            vl = Math.floor(values.length / 2);\n            return values.length % 2 ? values[vl] : (values[vl - 1] + values[vl]) / 2;\n        } else {\n            if (values.length % 2) {\n                // odd\n                vl = (values.length * q + q) / 4;\n                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];\n            } else {\n                //even\n                vl = (values.length * q + 2) / 4;\n                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];\n            }\n        }\n    };\n    let normalizeValue = function (val) {\n        let nf;\n        switch (val) {\n        case 'undefined':\n            val = undefined;\n            break;\n        case 'null':\n            val = null;\n            break;\n        case 'true':\n            val = true;\n            break;\n        case 'false':\n            val = false;\n            break;\n        default:\n            nf = parseFloat(val);\n            if (val == nf) {\n                val = nf;\n            }\n        }\n        return val;\n    };\n    let normalizeValues = function (vals) {\n        let i, result = [];\n        for (i = vals.length; i--;) {\n            result[i] = normalizeValue(vals[i]);\n        }\n        return result;\n    };\n    let all = function (val, arr, ignoreNull) {\n        let i;\n        for (i = arr.length; i--;) {\n            if (ignoreNull && arr[i] === null)\n                continue;\n            if (arr[i] !== val) {\n                return false;\n            }\n        }\n        return true;\n    };    // sums the numeric values in an array, ignoring other values\n    // sums the numeric values in an array, ignoring other values\n    let sum = function (vals) {\n        let total = 0, i;\n        for (i = vals.length; i--;) {\n            total += typeof vals[i] === 'number' ? vals[i] : 0;\n        }\n        return total;\n    };\n    let remove = function (vals, filter) {\n        let i, vl, result = [];\n        for (i = 0, vl = vals.length; i < vl; i++) {\n            if (vals[i] !== filter) {\n                result.push(vals[i]);\n            }\n        }\n        return result;\n    };\n    let isNumber = function (num) {\n        return !isNaN(parseFloat(num)) && isFinite(num);\n    };\n    let formatNumber = function (num, prec, groupsize, groupsep, decsep) {\n        let p, i;\n        num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');\n        p = (p = $.inArray('.', num)) < 0 ? num.length : p;\n        if (p < num.length) {\n            num[p] = decsep;\n        }\n        for (i = p - groupsize; i > 0; i -= groupsize) {\n            num.splice(i, 0, groupsep);\n        }\n        return num.join('');\n    };\n    let RangeMap = createClass({\n        init: function (map) {\n            let key, range, rangelist = [];\n            for (key in map) {\n                if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {\n                    range = key.split(':');\n                    range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);\n                    range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);\n                    range[2] = map[key];\n                    rangelist.push(range);\n                }\n            }\n            this.map = map;\n            this.rangelist = rangelist || false;\n        },\n        get: function (value) {\n            let rangelist = this.rangelist, i, range, result;\n            if ((result = this.map[value]) !== undefined) {\n                return result;\n            }\n            if (rangelist) {\n                for (i = rangelist.length; i--;) {\n                    range = rangelist[i];\n                    if (range[0] <= value && range[1] >= value) {\n                        return range[2];\n                    }\n                }\n            }\n            return undefined;\n        }\n    });    // Convenience function\n    // Convenience function\n    $.range_map = function (map) {\n        return new RangeMap(map);\n    };\n    const luckysheetSparkline = {\n        defaultOption: {\n            // Settings common to most/all chart types\n            common: {\n                type: 'line',\n                lineColor: '#2ec7c9',\n                fillColor: '#CCF3F4',\n                defaultPixelsPerValue: 3,\n                width: 'auto',\n                height: 'auto',\n                composite: false,\n                tagValuesAttribute: 'values',\n                tagOptionsPrefix: 'spark',\n                enableTagOptions: false,\n                enableHighlight: true,\n                highlightLighten: 1.4,\n                tooltipSkipNull: true,\n                tooltipPrefix: '',\n                tooltipSuffix: '',\n                disableHiddenCheck: false,\n                numberFormatter: false,\n                numberDigitGroupCount: 3,\n                numberDigitGroupSep: ',',\n                numberDecimalMark: '.',\n                disableTooltips: true,\n                disableInteraction: true,\n                offsetX: 0,\n                offsetY: 0\n            },\n            // Defaults for line charts\n            //=LINESPL\n            line: {\n                spotColor: 0,\n                highlightSpotColor: '#5f5',\n                highlightLineColor: '#f22',\n                spotRadius: 1.5,\n                minSpotColor: 0,\n                maxSpotColor: 0,\n                lineWidth: 1,\n                normalRangeMin: undefined,\n                normalRangeMax: undefined,\n                normalRangeColor: '#ccc',\n                drawNormalOnTop: true,\n                chartRangeMin: undefined,\n                chartRangeMax: undefined,\n                chartRangeMinX: undefined,\n                chartRangeMaxX: undefined\n            },\n            // tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{y}}{{suffix}}')\n            // Defaults for bar charts\n            bar: {\n                barColor: '#fc5c5c',\n                negBarColor: '#97b552',\n                stackedBarColor: [\n                    '#2ec7c9',\n                    '#fc5c5c',\n                    '#5ab1ef',\n                    '#ffb980',\n                    '#d87a80',\n                    '#8d98b3',\n                    '#e5cf0d',\n                    '#97b552',\n                    '#95706d',\n                    '#dc69aa',\n                    '#07a2a4',\n                    '#9a7fd1',\n                    '#588dd5',\n                    '#f5994e',\n                    '#c05050',\n                    '#59678c',\n                    '#c9ab00',\n                    '#7eb00a',\n                    '#6f5553',\n                    '#c14089'\n                ],\n                zeroColor: undefined,\n                nullColor: undefined,\n                zeroAxis: true,\n                barWidth: 4,\n                barSpacing: 1,\n                chartRangeMax: undefined,\n                chartRangeMin: undefined,\n                chartRangeClip: false,\n                colorMap: undefined\n            },\n            // tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{value}}{{suffix}}')\n            column: {\n                barColor: '#fc5c5c',\n                negBarColor: '#97b552',\n                stackedBarColor: [\n                    '#2ec7c9',\n                    '#fc5c5c',\n                    '#5ab1ef',\n                    '#ffb980',\n                    '#d87a80',\n                    '#8d98b3',\n                    '#e5cf0d',\n                    '#97b552',\n                    '#95706d',\n                    '#dc69aa',\n                    '#07a2a4',\n                    '#9a7fd1',\n                    '#588dd5',\n                    '#f5994e',\n                    '#c05050',\n                    '#59678c',\n                    '#c9ab00',\n                    '#7eb00a',\n                    '#6f5553',\n                    '#c14089'\n                ],\n                zeroColor: undefined,\n                nullColor: undefined,\n                zeroAxis: true,\n                barWidth: 4,\n                barSpacing: 1,\n                chartRangeMax: undefined,\n                chartRangeMin: undefined,\n                chartRangeClip: false,\n                colorMap: undefined\n            },\n            // tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{value}}{{suffix}}')\n            // Defaults for tristate charts\n            tristate: {\n                barWidth: 4,\n                barSpacing: 1,\n                posBarColor: '#fc5c5c',\n                negBarColor: '#97b552',\n                zeroBarColor: '#999',\n                colorMap: {}\n            },\n            // tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value:map}}'),\n            // tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }\n            // Defaults for discrete charts\n            discrete: {\n                lineHeight: 'auto',\n                thresholdColor: '#fc5c5c',\n                thresholdValue: 0,\n                chartRangeMax: undefined,\n                chartRangeMin: undefined,\n                chartRangeClip: false\n            },\n            // tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')\n            // Defaults for bullet charts\n            bullet: {\n                targetColor: '#f33',\n                targetWidth: 3,\n                // width of the target bar in pixels\n                performanceColor: '#33f',\n                rangeColors: [\n                    '#d3dafe',\n                    '#a8b6ff',\n                    '#7f94ff',\n                    '#6D87FF',\n                    '#5876FF',\n                    '#4465FF',\n                    '#2F54FF',\n                    '#1A43FF',\n                    '#0532FF'\n                ],\n                base: undefined\n            },\n            // set this to a number to change the base start number\n            // tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),\n            // tooltipValueLookups: { fields: {r: 'Range', p: 'Performance', t: 'Target'} }\n            // Defaults for pie charts\n            pie: {\n                offset: 0,\n                sliceColors: [\n                    '#2ec7c9',\n                    '#fc5c5c',\n                    '#5ab1ef',\n                    '#ffb980',\n                    '#d87a80',\n                    '#8d98b3',\n                    '#e5cf0d',\n                    '#97b552',\n                    '#95706d',\n                    '#dc69aa',\n                    '#07a2a4',\n                    '#9a7fd1',\n                    '#588dd5',\n                    '#f5994e',\n                    '#c05050',\n                    '#59678c',\n                    '#c9ab00',\n                    '#7eb00a',\n                    '#6f5553',\n                    '#c14089'\n                ],\n                borderWidth: 0,\n                borderColor: '#000'\n            },\n            // tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value}} ({{percent.1}}%)')\n            // Defaults for box plots\n            box: {\n                raw: false,\n                boxLineColor: '#000',\n                boxFillColor: '#cdf',\n                whiskerColor: '#000',\n                outlierLineColor: '#5E5E5E',\n                outlierFillColor: '#fff',\n                medianColor: '#f00',\n                showOutliers: true,\n                outlierIQR: 1.5,\n                spotRadius: 1.5,\n                target: undefined,\n                targetColor: '#4a2',\n                chartRangeMax: undefined,\n                chartRangeMin: undefined\n            }\n        },\n        // tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),\n        // tooltipFormatFieldlistKey: 'field',\n        // tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',\n        //     uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',\n        //     lw: 'Left Whisker', rw: 'Right Whisker'} }\n        line: {\n            type: 'line',\n            init: function (el, values, options, width, height) {\n                //line._super.init.call(this, el, values, options, width, height);\n                this.vertices = [];\n                this.regionMap = [];\n                this.xvalues = [];\n                this.yvalues = [];\n                this.yminmax = [];\n                this.hightlightSpotId = null;\n                this.lastShapeId = null;    //this.initTarget();\n            },\n            //this.initTarget();\n            getRegion: function (el, x, y) {\n                let i, regionMap = this.regionMap;    // maps regions to value positions\n                // maps regions to value positions\n                for (i = regionMap.length; i--;) {\n                    if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {\n                        return regionMap[i][2];\n                    }\n                }\n                return undefined;\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion;\n                return {\n                    isNull: this.yvalues[currentRegion] === null,\n                    x: this.xvalues[currentRegion],\n                    y: this.yvalues[currentRegion],\n                    color: this.options.get('lineColor'),\n                    fillColor: this.options.get('fillColor'),\n                    offset: currentRegion\n                };\n            },\n            renderHighlight: function () {\n                let currentRegion = this.currentRegion, target = this.target, vertex = this.vertices[currentRegion], options = this.options, spotRadius = options.get('spotRadius'), highlightSpotColor = options.get('highlightSpotColor'), highlightLineColor = options.get('highlightLineColor'), highlightSpot, highlightLine;\n                if (!vertex) {\n                    return;\n                }\n                if (spotRadius && highlightSpotColor) {\n                    highlightSpot = target.drawCircle(vertex[0], vertex[1], spotRadius, undefined, highlightSpotColor);\n                    this.highlightSpotId = highlightSpot.id;\n                    target.insertAfterShape(this.lastShapeId, highlightSpot);\n                }\n                if (highlightLineColor) {\n                    highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0], this.canvasTop + this.canvasHeight, highlightLineColor);\n                    this.highlightLineId = highlightLine.id;\n                    target.insertAfterShape(this.lastShapeId, highlightLine);\n                }\n            },\n            removeHighlight: function () {\n                let target = this.target;\n                if (this.highlightSpotId) {\n                    target.removeShapeId(this.highlightSpotId);\n                    this.highlightSpotId = null;\n                }\n                if (this.highlightLineId) {\n                    target.removeShapeId(this.highlightLineId);\n                    this.highlightLineId = null;\n                }\n            },\n            scanValues: function () {\n                let values = this.values, valcount = values.length, xvalues = this.xvalues, yvalues = this.yvalues, yminmax = this.yminmax, i, val, isStr, isArray, sp;\n                for (i = 0; i < valcount; i++) {\n                    val = values[i];\n                    isStr = typeof values[i] === 'string';\n                    isArray = typeof values[i] === 'object' && values[i] instanceof Array;\n                    sp = isStr && values[i].split(':');\n                    if (isStr && sp.length === 2) {\n                        // x:y\n                        xvalues.push(Number(sp[0]));\n                        yvalues.push(Number(sp[1]));\n                        yminmax.push(Number(sp[1]));\n                    } else if (isArray) {\n                        xvalues.push(val[0]);\n                        yvalues.push(val[1]);\n                        yminmax.push(val[1]);\n                    } else {\n                        xvalues.push(i);\n                        if (values[i] === null || values[i] === 'null') {\n                            yvalues.push(null);\n                        } else {\n                            yvalues.push(Number(val));\n                            yminmax.push(Number(val));\n                        }\n                    }\n                }\n                if (this.options.get('xvalues')) {\n                    xvalues = this.options.get('xvalues');\n                }\n                this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);\n                this.miny = this.minyorg = Math.min.apply(Math, yminmax);\n                this.maxx = Math.max.apply(Math, xvalues);\n                this.minx = Math.min.apply(Math, xvalues);\n                this.xvalues = xvalues;\n                this.yvalues = yvalues;\n                this.yminmax = yminmax;\n            },\n            processRangeOptions: function () {\n                let options = this.options, normalRangeMin = options.get('normalRangeMin'), normalRangeMax = options.get('normalRangeMax');\n                if (normalRangeMin !== undefined) {\n                    if (normalRangeMin < this.miny) {\n                        this.miny = normalRangeMin;\n                    }\n                    if (normalRangeMax > this.maxy) {\n                        this.maxy = normalRangeMax;\n                    }\n                }\n                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {\n                    this.miny = options.get('chartRangeMin');\n                }\n                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {\n                    this.maxy = options.get('chartRangeMax');\n                }\n                if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {\n                    this.minx = options.get('chartRangeMinX');\n                }\n                if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {\n                    this.maxx = options.get('chartRangeMaxX');\n                }\n            },\n            drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {\n                let normalRangeMin = this.options.get('normalRangeMin'), normalRangeMax = this.options.get('normalRangeMax'), ytop = canvasTop + Math.round(canvasHeight - canvasHeight * ((normalRangeMax - this.miny) / rangey)), height = Math.round(canvasHeight * (normalRangeMax - normalRangeMin) / rangey);    //(x1, y1, x2, y2, lineColor, lineWidth)\n                //(x1, y1, x2, y2, lineColor, lineWidth)\n                if (height == 0 && normalRangeMin == normalRangeMax) {\n                    height = 1;\n                }\n                this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();\n            },\n            render: function (el, userValues) {\n                this.vertices = [];\n                this.regionMap = [];\n                this.xvalues = [];\n                this.yvalues = [];\n                this.yminmax = [];\n                this.hightlightSpotId = null;\n                this.lastShapeId = null;\n                this.values = userValues;\n                let options = this.options, target = this.target, canvasWidth = el.mergedOptions.width, canvasHeight = el.mergedOptions.height, vertices = this.vertices, spotRadius = options.get('spotRadius'), regionMap = this.regionMap, rangex, rangey, yvallast, canvasTop, canvasLeft, vertex, path, paths, x, y, xnext, xpos, xposnext, last, next, yvalcount, lineShapes, fillShapes, plen, valueSpots, hlSpotsEnabled, color, xvalues, yvalues, i;    // if (!line._super.render.call(this)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 //     return;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // }\n                // if (!line._super.render.call(this)) {\n                //     return;\n                // }\n                this.scanValues();\n                this.processRangeOptions();\n                xvalues = this.xvalues;\n                yvalues = this.yvalues;\n                if (!this.yminmax.length || this.yvalues.length < 2) {\n                    // empty or all null valuess\n                    return;\n                }\n                canvasTop = canvasLeft = 0;\n                rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;\n                rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;\n                yvallast = this.yvalues.length - 1;\n                if (spotRadius && (canvasWidth < spotRadius * 4 || canvasHeight < spotRadius * 4)) {\n                    spotRadius = 0;\n                }\n                if (spotRadius) {\n                    // adjust the canvas size as required so that spots will fit\n                    hlSpotsEnabled = options.get('highlightSpotColor') && !options.get('disableInteraction');\n                    if (hlSpotsEnabled || options.get('minSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.miny) {\n                        canvasHeight -= Math.ceil(spotRadius);\n                    }\n                    if (hlSpotsEnabled || options.get('maxSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.maxy) {\n                        canvasHeight -= Math.ceil(spotRadius);\n                        canvasTop += Math.ceil(spotRadius);\n                    }\n                    if (hlSpotsEnabled || (options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy)) {\n                        canvasLeft += Math.ceil(spotRadius);\n                        canvasWidth -= Math.ceil(spotRadius);\n                    }\n                    if (hlSpotsEnabled || options.get('spotColor') || (options.get('minSpotColor') || options.get('maxSpotColor') && (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy))) {\n                        canvasWidth -= Math.ceil(spotRadius);\n                    }\n                }\n                canvasHeight--;\n                if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {\n                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n                }\n                path = [];\n                paths = [path];\n                last = next = null;\n                yvalcount = yvalues.length;\n                for (i = 0; i < yvalcount; i++) {\n                    x = xvalues[i];\n                    xnext = xvalues[i + 1];\n                    y = yvalues[i];\n                    xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));\n                    xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;\n                    next = xpos + (xposnext - xpos) / 2;\n                    regionMap[i] = [\n                        last || 0,\n                        next,\n                        i\n                    ];\n                    last = next;\n                    if (y === null) {\n                        if (i) {\n                            if (yvalues[i - 1] !== null) {\n                                path = [];\n                                paths.push(path);\n                            }\n                            vertices.push(null);\n                        }\n                    } else {\n                        if (y < this.miny) {\n                            y = this.miny;\n                        }\n                        if (y > this.maxy) {\n                            y = this.maxy;\n                        }\n                        if (!path.length) {\n                            // previous value was null\n                            path.push([\n                                xpos,\n                                canvasTop + canvasHeight\n                            ]);\n                        }\n                        vertex = [\n                            xpos,\n                            canvasTop + Math.round(canvasHeight - canvasHeight * ((y - this.miny) / rangey))\n                        ];\n                        path.push(vertex);\n                        vertices.push(vertex);\n                    }\n                }\n                lineShapes = [];\n                fillShapes = [];\n                plen = paths.length;\n                for (i = 0; i < plen; i++) {\n                    path = paths[i];\n                    if (path.length) {\n                        if (options.get('fillColor')) {\n                            path.push([\n                                path[path.length - 1][0],\n                                canvasTop + canvasHeight\n                            ]);\n                            fillShapes.push(path.slice(0));\n                            path.pop();\n                        }    // if there's only a single point in this path, then we want to display it\n                             // as a vertical line which means we keep path[0]  as is\n                        // if there's only a single point in this path, then we want to display it\n                        // as a vertical line which means we keep path[0]  as is\n                        if (path.length > 2) {\n                            // else we want the first value\n                            path[0] = [\n                                path[0][0],\n                                path[1][1]\n                            ];\n                        }\n                        lineShapes.push(path);\n                    }\n                }    // draw the fill first, then optionally the normal range, then the line on top of that\n                // draw the fill first, then optionally the normal range, then the line on top of that\n                plen = fillShapes.length;\n                for (i = 0; i < plen; i++) {\n                    target.drawShape(fillShapes[i], options.get('fillColor'), options.get('fillColor')).append();\n                }\n                plen = lineShapes.length;\n                for (i = 0; i < plen; i++) {\n                    target.drawShape(lineShapes[i], options.get('lineColor'), undefined, options.get('lineWidth')).append();\n                }\n                if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {\n                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n                }\n                if (spotRadius && options.get('valueSpots')) {\n                    valueSpots = options.get('valueSpots');\n                    if (valueSpots.get === undefined) {\n                        valueSpots = new RangeMap(valueSpots);\n                    }\n                    for (i = 0; i < yvalcount; i++) {\n                        color = valueSpots.get(yvalues[i]);\n                        if (color) {\n                            target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[i] - this.miny) / rangey)), spotRadius, undefined, color).append();\n                        }\n                    }\n                }\n                if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {\n                    target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[yvallast] - this.miny) / rangey)), spotRadius, undefined, options.get('spotColor')).append();\n                }\n                if (this.maxy !== this.minyorg) {\n                    if (spotRadius && options.get('minSpotColor')) {\n                        x = xvalues[$.inArray(this.minyorg, yvalues)];\n                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.minyorg - this.miny) / rangey)), spotRadius, undefined, options.get('minSpotColor')).append();\n                    }\n                    if (spotRadius && options.get('maxSpotColor')) {\n                        x = xvalues[$.inArray(this.maxyorg, yvalues)];\n                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.maxyorg - this.miny) / rangey)), spotRadius, undefined, options.get('maxSpotColor')).append();\n                    }\n                }    // this.lastShapeId = target.getLastShapeId();\n                     // this.canvasTop = canvasTop;\n                     // target.render();\n            }\n        },\n        // this.lastShapeId = target.getLastShapeId();\n        // this.canvasTop = canvasTop;\n        // target.render();\n        bar: {\n            type: 'bar',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.height;\n                let height = el.mergedOptions.width;\n                this.canvasWidth = el.mergedOptions.height;\n                this.canvasHeight = el.mergedOptions.width;\n                let barWidth = parseInt(options.get('barWidth'), 10), barSpacing = parseInt(options.get('barSpacing'), 10), chartRangeMin = options.get('chartRangeMin'), chartRangeMax = options.get('chartRangeMax'), chartRangeClip = options.get('chartRangeClip'), stackMin = Infinity, stackMax = -Infinity, isStackString, groupMin, groupMax, stackRanges, numValues, i, vlen, range, zeroAxis, xaxisOffset, min, max, clipMin, clipMax, stacked, vlist, j, slen, svals, val, yoffset, yMaxCalc, canvasHeightEf;    //bar._super.init.call(this, el, values, options, width, height);\n                //bar._super.init.call(this, el, values, options, width, height);\n                this.values = values;    // scan values to determine whether to stack bars\n                // scan values to determine whether to stack bars\n                for (i = 0, vlen = values.length; i < vlen; i++) {\n                    val = values[i];\n                    isStackString = typeof val === 'string' && val.indexOf(':') > -1;\n                    if (isStackString || $.isArray(val)) {\n                        stacked = true;\n                        if (isStackString) {\n                            val = values[i] = normalizeValues(val.split(':'));\n                        }\n                        val = remove(val, null);    // min/max will treat null as zero\n                        // min/max will treat null as zero\n                        groupMin = Math.min.apply(Math, val);\n                        groupMax = Math.max.apply(Math, val);\n                        if (groupMin < stackMin) {\n                            stackMin = groupMin;\n                        }\n                        if (groupMax > stackMax) {\n                            stackMax = groupMax;\n                        }\n                    }\n                }\n                this.stacked = stacked;\n                this.regionShapes = {};\n                this.barWidth = Math.floor(width / values.length) - barSpacing;\n                this.barSpacing = barSpacing;\n                this.totalBarWidth = this.barWidth + barSpacing;    //this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);\n                //this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);\n                this.width = width;    //this.initTarget();\n                //this.initTarget();\n                if (chartRangeClip) {\n                    clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;\n                    clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;\n                }\n                numValues = [];\n                stackRanges = stacked ? [] : numValues;\n                let stackTotals = [];\n                let stackRangesNeg = [];\n                for (i = 0, vlen = values.length; i < vlen; i++) {\n                    if (stacked) {\n                        vlist = values[i];\n                        values[i] = svals = [];\n                        stackTotals[i] = 0;\n                        stackRanges[i] = stackRangesNeg[i] = 0;\n                        for (j = 0, slen = vlist.length; j < slen; j++) {\n                            val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];\n                            if (val !== null) {\n                                if (val > 0) {\n                                    stackTotals[i] += val;\n                                }\n                                if (stackMin < 0 && stackMax > 0) {\n                                    if (val < 0) {\n                                        stackRangesNeg[i] += Math.abs(val);\n                                    } else {\n                                        stackRanges[i] += val;\n                                    }\n                                } else {\n                                    stackRanges[i] += Math.abs(val);    // stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                                }\n                                // stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                                numValues.push(val);\n                            }\n                        }\n                    } else {\n                        val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];\n                        val = values[i] = normalizeValue(val);\n                        if (val !== null) {\n                            numValues.push(val);\n                        }\n                    }\n                }\n                this.max = max = Math.max.apply(Math, numValues);\n                this.min = min = Math.min.apply(Math, numValues);\n                this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;\n                this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;\n                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {\n                    min = options.get('chartRangeMin');\n                }\n                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {\n                    max = options.get('chartRangeMax');\n                }\n                this.zeroAxis = zeroAxis = options.get('zeroAxis', true);\n                if (min <= 0 && max >= 0 && zeroAxis) {\n                    xaxisOffset = 0;\n                } else if (zeroAxis == false) {\n                    xaxisOffset = min;\n                } else if (min > 0) {\n                    xaxisOffset = 0;\n                } else {\n                    xaxisOffset = max;\n                }\n                this.xaxisOffset = xaxisOffset;\n                range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - xaxisOffset;    // as we plot zero/min values a single pixel line, we add a pixel to all other\n                                                                                                                                   // values - Reduce the effective canvas size to suit\n                // as we plot zero/min values a single pixel line, we add a pixel to all other\n                // values - Reduce the effective canvas size to suit\n                this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;\n                this.isNeg = false;\n                if (min < xaxisOffset) {\n                    // yMaxCalc = (stacked && max >= 0) ? stackMax : max;\n                    // yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;\n                    yoffset = Math.floor(this.canvasHeight / 2);\n                    this.isNeg = true;\n                    if (yoffset !== Math.ceil(yoffset)) {\n                        this.canvasHeightEf -= 2;\n                        yoffset = Math.ceil(yoffset);\n                    }\n                } else {\n                    yoffset = 0;\n                }\n                this.yoffset = yoffset;\n                if ($.isArray(options.get('colorMap'))) {\n                    this.colorMapByIndex = options.get('colorMap');\n                    this.colorMapByValue = null;\n                } else {\n                    this.colorMapByIndex = null;\n                    this.colorMapByValue = options.get('colorMap');\n                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n                        this.colorMapByValue = new RangeMap(this.colorMapByValue);\n                    }\n                }\n                this.range = range;\n            },\n            getRegion: function (el, x, y) {\n                let result = Math.floor(x / this.totalBarWidth);\n                return result < 0 || result >= this.values.length ? undefined : result;\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion, values = ensureArray(this.values[currentRegion]), result = [], value, i;\n                for (i = values.length; i--;) {\n                    value = values[i];\n                    result.push({\n                        isNull: value === null,\n                        value: value,\n                        color: this.calcColor(i, value, currentRegion),\n                        offset: currentRegion\n                    });\n                }\n                return result;\n            },\n            calcColor: function (stacknum, value, valuenum) {\n                let colorMapByIndex = this.colorMapByIndex, colorMapByValue = this.colorMapByValue, options = this.options, color, newColor;\n                if (this.stacked) {\n                    color = options.get('stackedBarColor');\n                } else {\n                    color = value < 0 ? options.get('negBarColor') : options.get('barColor');\n                }\n                if (value === 0 && options.get('zeroColor') !== undefined) {\n                    color = options.get('zeroColor');\n                }\n                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n                    color = newColor;\n                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n                    color = colorMapByIndex[valuenum];\n                }\n                return $.isArray(color) ? color[stacknum % color.length] : color;\n            },\n            /**\n         * Render bar(s) for a region\n         */\n            renderRegion: function (valuenum, highlight) {\n                let vals = this.values[valuenum], options = this.options, xaxisOffset = this.xaxisOffset, result = [], range = this.range, stacked = this.stacked, target = this.target, x = valuenum * this.totalBarWidth, canvasHeightEf = this.canvasHeightEf, yoffset = this.yoffset, y, height, color, isNull, yoffsetNeg, i, valcount, val, minPlotted, allMin;\n                vals = $.isArray(vals) ? vals : [vals];\n                valcount = vals.length;\n                val = vals[0];\n                isNull = all(null, vals);\n                allMin = all(xaxisOffset, vals, true);\n                if (isNull) {\n                    if (options.get('nullColor')) {\n                        color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);\n                        y = yoffset > 0 ? yoffset - 1 : yoffset;\n                        return target.drawRect(y, x, 0, this.barWidth - 1, color, color);\n                    } else {\n                        return undefined;\n                    }\n                }\n                yoffsetNeg = yoffset;\n                if (this.isNeg) {\n                    canvasHeightEf = Math.floor(canvasHeightEf / 2);\n                }\n                for (i = 0; i < valcount; i++) {\n                    val = vals[i];\n                    if (stacked && val === xaxisOffset) {\n                        if (!allMin || minPlotted) {\n                            continue;\n                        }\n                        minPlotted = true;\n                    }\n                    if (range > 0) {\n                        height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range));\n                    } else {\n                        height = canvasHeightEf;\n                    }\n                    if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {\n                        y = yoffsetNeg - height;\n                        yoffsetNeg += height;\n                    } else {\n                        if (stacked) {\n                            y = yoffset;\n                            yoffset += height;\n                        } else {\n                            y = yoffset;\n                            yoffset -= height;\n                        }\n                    }\n                    color = this.calcColor(i, val, valuenum);\n                    if (highlight) {\n                        color = this.calcHighlightColor(color, options);\n                    }\n                    result.push(target.drawRect(y, x, height - 1, this.barWidth - 1, color, color));\n                }\n                if (result.length === 1) {\n                    return result[0];\n                }\n                return result;\n            }\n        },\n        column: {\n            type: 'column',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.width;\n                let height = el.mergedOptions.height;\n                this.canvasWidth = el.mergedOptions.width;\n                this.canvasHeight = el.mergedOptions.height;\n                let barWidth = parseInt(options.get('barWidth'), 10), barSpacing = parseInt(options.get('barSpacing'), 10), chartRangeMin = options.get('chartRangeMin'), chartRangeMax = options.get('chartRangeMax'), chartRangeClip = options.get('chartRangeClip'), stackMin = Infinity, stackMax = -Infinity, isStackString, groupMin, groupMax, stackRanges, numValues, i, vlen, range, zeroAxis, xaxisOffset, min, max, clipMin, clipMax, stacked, vlist, j, slen, svals, val, yoffset, yMaxCalc, canvasHeightEf;    //bar._super.init.call(this, el, values, options, width, height);\n                //bar._super.init.call(this, el, values, options, width, height);\n                this.values = values;    // scan values to determine whether to stack bars\n                // scan values to determine whether to stack bars\n                for (i = 0, vlen = values.length; i < vlen; i++) {\n                    val = values[i];\n                    isStackString = typeof val === 'string' && val.indexOf(':') > -1;\n                    if (isStackString || $.isArray(val)) {\n                        stacked = true;\n                        if (isStackString) {\n                            val = values[i] = normalizeValues(val.split(':'));\n                        }\n                        val = remove(val, null);    // min/max will treat null as zero\n                        // min/max will treat null as zero\n                        groupMin = Math.min.apply(Math, val);\n                        groupMax = Math.max.apply(Math, val);\n                        if (groupMin < stackMin) {\n                            stackMin = groupMin;\n                        }\n                        if (groupMax > stackMax) {\n                            stackMax = groupMax;\n                        }\n                    }\n                }\n                this.stacked = stacked;\n                this.regionShapes = {};\n                this.barWidth = Math.floor(width / values.length) - barSpacing;\n                this.barSpacing = barSpacing;\n                this.totalBarWidth = this.barWidth + barSpacing;    //this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);\n                //this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);\n                this.width = width;    //this.initTarget();\n                //this.initTarget();\n                if (chartRangeClip) {\n                    clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;\n                    clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;\n                }\n                numValues = [];\n                stackRanges = stacked ? [] : numValues;\n                let stackTotals = [];\n                let stackRangesNeg = [];\n                for (i = 0, vlen = values.length; i < vlen; i++) {\n                    if (stacked) {\n                        vlist = values[i];\n                        values[i] = svals = [];\n                        stackTotals[i] = 0;\n                        stackRanges[i] = stackRangesNeg[i] = 0;\n                        for (j = 0, slen = vlist.length; j < slen; j++) {\n                            val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];\n                            if (val !== null) {\n                                if (val > 0) {\n                                    stackTotals[i] += val;\n                                }\n                                if (stackMin < 0 && stackMax > 0) {\n                                    if (val < 0) {\n                                        stackRangesNeg[i] += Math.abs(val);\n                                    } else {\n                                        stackRanges[i] += val;\n                                    }\n                                } else {\n                                    stackRanges[i] += Math.abs(val);    // stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                                }\n                                // stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                                numValues.push(val);\n                            }\n                        }\n                    } else {\n                        val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];\n                        val = values[i] = normalizeValue(val);\n                        if (val !== null) {\n                            numValues.push(val);\n                        }\n                    }\n                }\n                this.max = max = Math.max.apply(Math, numValues);\n                this.min = min = Math.min.apply(Math, numValues);\n                this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;\n                this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;\n                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {\n                    min = options.get('chartRangeMin');\n                }\n                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {\n                    max = options.get('chartRangeMax');\n                }\n                this.zeroAxis = zeroAxis = options.get('zeroAxis', true);\n                if (min <= 0 && max >= 0 && zeroAxis) {\n                    xaxisOffset = 0;\n                } else if (zeroAxis == false) {\n                    xaxisOffset = min;\n                } else if (min > 0) {\n                    xaxisOffset = 0;\n                } else {\n                    xaxisOffset = max;\n                }\n                this.xaxisOffset = xaxisOffset;\n                range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - xaxisOffset;    // as we plot zero/min values a single pixel line, we add a pixel to all other\n                                                                                                                                   // values - Reduce the effective canvas size to suit\n                // as we plot zero/min values a single pixel line, we add a pixel to all other\n                // values - Reduce the effective canvas size to suit\n                this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;\n                this.isNeg = false;\n                if (min < xaxisOffset) {\n                    // yMaxCalc = (stacked && max >= 0) ? stackMax : max;\n                    // yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;\n                    yoffset = Math.floor(this.canvasHeight / 2);\n                    this.isNeg = true;\n                    if (yoffset !== Math.ceil(yoffset)) {\n                        this.canvasHeightEf -= 2;\n                        yoffset = Math.ceil(yoffset);\n                    }\n                } else {\n                    yoffset = this.canvasHeight;\n                }\n                this.yoffset = yoffset;\n                if ($.isArray(options.get('colorMap'))) {\n                    this.colorMapByIndex = options.get('colorMap');\n                    this.colorMapByValue = null;\n                } else {\n                    this.colorMapByIndex = null;\n                    this.colorMapByValue = options.get('colorMap');\n                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n                        this.colorMapByValue = new RangeMap(this.colorMapByValue);\n                    }\n                }\n                this.range = range;\n            },\n            getRegion: function (el, x, y) {\n                let result = Math.floor(x / this.totalBarWidth);\n                return result < 0 || result >= this.values.length ? undefined : result;\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion, values = ensureArray(this.values[currentRegion]), result = [], value, i;\n                for (i = values.length; i--;) {\n                    value = values[i];\n                    result.push({\n                        isNull: value === null,\n                        value: value,\n                        color: this.calcColor(i, value, currentRegion),\n                        offset: currentRegion\n                    });\n                }\n                return result;\n            },\n            calcColor: function (stacknum, value, valuenum) {\n                let colorMapByIndex = this.colorMapByIndex, colorMapByValue = this.colorMapByValue, options = this.options, color, newColor;\n                if (this.stacked) {\n                    color = options.get('stackedBarColor');\n                } else {\n                    color = value < 0 ? options.get('negBarColor') : options.get('barColor');\n                }\n                if (value === 0 && options.get('zeroColor') !== undefined) {\n                    color = options.get('zeroColor');\n                }\n                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n                    color = newColor;\n                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n                    color = colorMapByIndex[valuenum];\n                }\n                return $.isArray(color) ? color[stacknum % color.length] : color;\n            },\n            /**\n         * Render bar(s) for a region\n         */\n            renderRegion: function (valuenum, highlight) {\n                let vals = this.values[valuenum], options = this.options, xaxisOffset = this.xaxisOffset, result = [], range = this.range, stacked = this.stacked, target = this.target, x = valuenum * this.totalBarWidth, canvasHeightEf = this.canvasHeightEf, yoffset = this.yoffset, y, height, color, isNull, yoffsetNeg, i, valcount, val, minPlotted, allMin;\n                vals = $.isArray(vals) ? vals : [vals];\n                valcount = vals.length;\n                val = vals[0];\n                isNull = all(null, vals);\n                allMin = all(xaxisOffset, vals, true);\n                if (isNull) {\n                    if (options.get('nullColor')) {\n                        color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);\n                        y = yoffset > 0 ? yoffset - 1 : yoffset;\n                        return target.drawRect(x, y, this.barWidth - 1, 0, color, color);\n                    } else {\n                        return undefined;\n                    }\n                }\n                yoffsetNeg = yoffset;\n                if (this.isNeg) {\n                    canvasHeightEf = Math.floor(canvasHeightEf / 2);\n                }\n                for (i = 0; i < valcount; i++) {\n                    val = vals[i];\n                    if (stacked && val === xaxisOffset) {\n                        if (!allMin || minPlotted) {\n                            continue;\n                        }\n                        minPlotted = true;\n                    }\n                    if (range > 0) {\n                        height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range));\n                    } else {\n                        height = canvasHeightEf;\n                    }\n                    if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {\n                        y = yoffsetNeg;\n                        yoffsetNeg += height;\n                    } else {\n                        y = yoffset - height;\n                        yoffset -= height;\n                    }\n                    color = this.calcColor(i, val, valuenum);\n                    if (highlight) {\n                        color = this.calcHighlightColor(color, options);\n                    }\n                    result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));\n                }\n                if (result.length === 1) {\n                    return result[0];\n                }\n                return result;\n            }\n        },\n        tristate: {\n            type: 'tristate',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.width;\n                let height = el.mergedOptions.height;\n                this.canvasWidth = el.mergedOptions.width;\n                this.canvasHeight = el.mergedOptions.height;\n                let barWidth = parseInt(options.get('barWidth'), 10), barSpacing = parseInt(options.get('barSpacing'), 10);    //tristate._super.init.call(this, el, values, options, width, height);\n                //tristate._super.init.call(this, el, values, options, width, height);\n                this.regionShapes = {};\n                this.barWidth = barWidth;\n                this.barSpacing = barSpacing;\n                this.totalBarWidth = barWidth + barSpacing;\n                this.values = $.map(values, Number);\n                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;\n                if ($.isArray(options.get('colorMap'))) {\n                    this.colorMapByIndex = options.get('colorMap');\n                    this.colorMapByValue = null;\n                } else {\n                    this.colorMapByIndex = null;\n                    this.colorMapByValue = options.get('colorMap');\n                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n                        this.colorMapByValue = new RangeMap(this.colorMapByValue);\n                    }\n                }    //this.initTarget();\n            },\n            //this.initTarget();\n            getRegion: function (el, x, y) {\n                return Math.floor(x / this.totalBarWidth);\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion;\n                return {\n                    isNull: this.values[currentRegion] === undefined,\n                    value: this.values[currentRegion],\n                    color: this.calcColor(this.values[currentRegion], currentRegion),\n                    offset: currentRegion\n                };\n            },\n            calcColor: function (value, valuenum) {\n                let values = this.values, options = this.options, colorMapByIndex = this.colorMapByIndex, colorMapByValue = this.colorMapByValue, color, newColor;\n                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n                    color = newColor;\n                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n                    color = colorMapByIndex[valuenum];\n                } else if (values[valuenum] < 0) {\n                    color = options.get('negBarColor');\n                } else if (values[valuenum] > 0) {\n                    color = options.get('posBarColor');\n                } else {\n                    color = options.get('zeroBarColor');\n                }\n                return color;\n            },\n            renderRegion: function (valuenum, highlight) {\n                let values = this.values, options = this.options, target = this.target, canvasHeight, height, halfHeight, x, y, color;\n                canvasHeight = this.canvasHeight;\n                halfHeight = Math.round(canvasHeight / 2);\n                x = valuenum * this.totalBarWidth;\n                if (values[valuenum] < 0) {\n                    y = halfHeight;\n                    height = halfHeight - 1;\n                } else if (values[valuenum] > 0) {\n                    y = 0;\n                    height = halfHeight - 1;\n                } else {\n                    y = halfHeight - 1;\n                    height = 2;\n                }\n                color = this.calcColor(values[valuenum], valuenum);\n                if (color === null) {\n                    return;\n                }\n                if (highlight) {\n                    color = this.calcHighlightColor(color, options);\n                }\n                return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);\n            }\n        },\n        discrete: {\n            type: 'discrete',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.width;\n                let height = el.mergedOptions.height;\n                this.canvasWidth = el.mergedOptions.width;\n                this.canvasHeight = el.mergedOptions.height;\n                this.regionShapes = {};\n                this.values = values = $.map(values, Number);\n                this.min = Math.min.apply(Math, values);\n                this.max = Math.max.apply(Math, values);\n                this.range = this.max - this.min;\n                this.width = width;\n                this.interval = Math.floor(width / values.length);\n                this.itemWidth = width / values.length;\n                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {\n                    this.min = options.get('chartRangeMin');\n                }\n                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {\n                    this.max = options.get('chartRangeMax');\n                }    //this.initTarget();\n                //this.initTarget();\n                if (this.target) {\n                    this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');\n                }\n            },\n            getRegion: function (el, x, y) {\n                return Math.floor(x / this.itemWidth);\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion;\n                return {\n                    isNull: this.values[currentRegion] === undefined,\n                    value: this.values[currentRegion],\n                    offset: currentRegion\n                };\n            },\n            renderRegion: function (valuenum, highlight) {\n                let values = this.values, options = this.options, min = this.min, max = this.max, range = this.range, interval = this.interval, target = this.target, canvasHeight = this.canvasHeight, lineHeight = this.lineHeight, pheight = canvasHeight - lineHeight, ytop, val, color, x;\n                val = clipval(values[valuenum], min, max);\n                x = valuenum * interval;\n                ytop = Math.round(pheight - pheight * ((val - min) / range));\n                color = options.get('thresholdColor') && val < options.get('thresholdValue') ? options.get('thresholdColor') : options.get('lineColor');\n                if (highlight) {\n                    color = this.calcHighlightColor(color, options);\n                }    //return target.drawLine(x, ytop, x, ytop + lineHeight, color);\n                //return target.drawLine(x, ytop, x, ytop + lineHeight, color);\n                return this.target.drawRect(x, ytop, interval <= 2 ? 1 : interval - 2, lineHeight, color, color);\n            }\n        },\n        bullet: {\n            type: 'bullet',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.width;\n                let height = el.mergedOptions.height;\n                this.canvasWidth = el.mergedOptions.width;\n                this.canvasHeight = el.mergedOptions.height;\n                let min, max, vals;    //bullet._super.init.call(this, el, values, options, width, height);\n                                       // values: target, performance, range1, range2, range3\n                //bullet._super.init.call(this, el, values, options, width, height);\n                // values: target, performance, range1, range2, range3\n                this.values = values = normalizeValues(values);    // target or performance could be null\n                // target or performance could be null\n                vals = values.slice();\n                vals[0] = vals[0] === null ? vals[2] : vals[0];\n                vals[1] = values[1] === null ? vals[2] : vals[1];\n                min = Math.min.apply(Math, values);\n                max = Math.max.apply(Math, values);\n                if (options.get('base') === undefined) {\n                    min = min < 0 ? min : 0;\n                } else {\n                    min = options.get('base');\n                }\n                this.min = min;\n                this.max = max;\n                this.range = max - min;\n                this.shapes = {};\n                this.valueShapes = {};\n                this.regiondata = {};\n                this.width = width;    //this.target = this.$el.simpledraw(width, height, options.get('composite'));\n                //this.target = this.$el.simpledraw(width, height, options.get('composite'));\n                if (!values.length) {\n                    this.disabled = true;\n                }    //this.initTarget();\n            },\n            //this.initTarget();\n            getRegion: function (el, x, y) {\n                let shapeid = this.target.getShapeAt(el, x, y);\n                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion;\n                return {\n                    fieldkey: currentRegion.substr(0, 1),\n                    value: this.values[currentRegion.substr(1)],\n                    region: currentRegion\n                };\n            },\n            changeHighlight: function (highlight) {\n                let currentRegion = this.currentRegion, shapeid = this.valueShapes[currentRegion], shape;\n                delete this.shapes[shapeid];\n                switch (currentRegion.substr(0, 1)) {\n                case 'r':\n                    shape = this.renderRange(currentRegion.substr(1), highlight);\n                    break;\n                case 'p':\n                    shape = this.renderPerformance(highlight);\n                    break;\n                case 't':\n                    shape = this.renderTarget(highlight);\n                    break;\n                }\n                this.valueShapes[currentRegion] = shape.id;\n                this.shapes[shape.id] = currentRegion;\n                this.target.replaceWithShape(shapeid, shape);\n            },\n            renderRange: function (rn, highlight) {\n                let rangeval = this.values[rn], rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)), color = this.options.get('rangeColors')[rn - 2];\n                if (highlight) {\n                    color = this.calcHighlightColor(color, this.options);\n                }\n                return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);\n            },\n            renderPerformance: function (highlight) {\n                let perfval = this.values[1], perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)), color = this.options.get('performanceColor');\n                if (highlight) {\n                    color = this.calcHighlightColor(color, this.options);\n                }\n                return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1, Math.round(this.canvasHeight * 0.4) - 1, color, color);\n            },\n            renderTarget: function (highlight) {\n                let targetval = this.values[0], x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - this.options.get('targetWidth') / 2), targettop = Math.round(this.canvasHeight * 0.1), targetheight = this.canvasHeight - targettop * 2, color = this.options.get('targetColor');\n                if (highlight) {\n                    color = this.calcHighlightColor(color, this.options);\n                }\n                return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);\n            },\n            render: function (el, userValues) {\n                this.init(el, userValues);\n                let vlen = this.values.length, target = this.target, i, shape;    // if (!bullet._super.render.call(this)) {\n                                                                                  //     return;\n                                                                                  // }\n                // if (!bullet._super.render.call(this)) {\n                //     return;\n                // }\n                for (i = 2; i < vlen; i++) {\n                    shape = this.renderRange(i).append();\n                    this.shapes[shape.id] = 'r' + i;\n                    this.valueShapes['r' + i] = shape.id;\n                }\n                if (this.values[1] !== null) {\n                    shape = this.renderPerformance().append();\n                    this.shapes[shape.id] = 'p1';\n                    this.valueShapes.p1 = shape.id;\n                }\n                if (this.values[0] !== null) {\n                    shape = this.renderTarget().append();\n                    this.shapes[shape.id] = 't0';\n                    this.valueShapes.t0 = shape.id;\n                }    //target.render();\n            }\n        },\n        //target.render();\n        pie: {\n            type: 'pie',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.width;\n                let height = el.mergedOptions.height;\n                this.canvasWidth = el.mergedOptions.width;\n                this.canvasHeight = el.mergedOptions.height;\n                let total = 0, i;    //pie._super.init.call(this, el, values, options, width, height);\n                //pie._super.init.call(this, el, values, options, width, height);\n                this.shapes = {};    // map shape ids to value offsets\n                // map shape ids to value offsets\n                this.valueShapes = {};    // maps value offsets to shape ids\n                // maps value offsets to shape ids\n                this.values = values = $.map(values, Number);\n                if (options.get('width') === 'auto') {\n                    this.width = this.height;\n                }\n                if (values.length > 0) {\n                    for (i = values.length; i--;) {\n                        total += values[i];\n                    }\n                }\n                this.total = total;    //this.initTarget();\n                //this.initTarget();\n                this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);\n            },\n            getRegion: function (el, x, y) {\n                let shapeid = this.target.getShapeAt(el, x, y);\n                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;\n            },\n            getCurrentRegionFields: function () {\n                let currentRegion = this.currentRegion;\n                return {\n                    isNull: this.values[currentRegion] === undefined,\n                    value: this.values[currentRegion],\n                    percent: this.values[currentRegion] / this.total * 100,\n                    color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],\n                    offset: currentRegion\n                };\n            },\n            changeHighlight: function (highlight) {\n                let currentRegion = this.currentRegion, newslice = this.renderSlice(currentRegion, highlight), shapeid = this.valueShapes[currentRegion];\n                delete this.shapes[shapeid];\n                this.target.replaceWithShape(shapeid, newslice);\n                this.valueShapes[currentRegion] = newslice.id;\n                this.shapes[newslice.id] = currentRegion;\n            },\n            renderSlice: function (valuenum, highlight) {\n                let target = this.target, options = this.options, radius = this.radius, borderWidth = options.get('borderWidth'), offset = options.get('offset'), circle = 2 * Math.PI, values = this.values, total = this.total, next = offset ? 2 * Math.PI * (offset / 360) : 0, start, end, i, vlen, color;\n                vlen = values.length;\n                for (i = 0; i < vlen; i++) {\n                    start = next;\n                    end = next;\n                    if (total > 0) {\n                        // avoid divide by zero\n                        end = next + circle * (values[i] / total);\n                    }\n                    if (valuenum === i) {\n                        color = options.get('sliceColors')[i % options.get('sliceColors').length];\n                        if (highlight) {\n                            color = this.calcHighlightColor(color, options);\n                        }\n                        return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);\n                    }\n                    next = end;\n                }\n            },\n            render: function (el, userValues) {\n                this.init(el, userValues);\n                let target = this.target, values = this.values, options = this.options, radius = this.radius, borderWidth = options.get('borderWidth'), shape, i;    // if (!pie._super.render.call(this)) {\n                                                                                                                                                                     //     return;\n                                                                                                                                                                     // }\n                // if (!pie._super.render.call(this)) {\n                //     return;\n                // }\n                if (borderWidth) {\n                    target.drawCircle(radius, radius, Math.floor(radius - borderWidth / 2), options.get('borderColor'), undefined, borderWidth).append();\n                }\n                for (i = values.length; i--;) {\n                    if (values[i]) {\n                        // don't render zero values\n                        shape = this.renderSlice(i).append();\n                        this.valueShapes[i] = shape.id;    // store just the shapeid\n                        // store just the shapeid\n                        this.shapes[shape.id] = i;\n                    }\n                }    //target.render();\n            }\n        },\n        //target.render();\n        box: {\n            type: 'box',\n            init: function (el, values) {\n                let options = this.options;\n                let width = el.mergedOptions.width;\n                let height = el.mergedOptions.height;\n                this.canvasWidth = el.mergedOptions.width;\n                this.canvasHeight = el.mergedOptions.height;    //box._super.init.call(this, el, values, options, width, height);\n                //box._super.init.call(this, el, values, options, width, height);\n                this.values = $.map(values, Number);\n                this.width = options.get('width') === 'auto' ? '4.0em' : width;    //this.initTarget();\n                //this.initTarget();\n                if (!this.values.length) {\n                    this.disabled = 1;\n                }\n            },\n            /**\n         * Simulate a single region\n         */\n            getRegion: function () {\n                return 1;\n            },\n            getCurrentRegionFields: function () {\n                let result = [\n                    {\n                        field: 'lq',\n                        value: this.quartiles[0]\n                    },\n                    {\n                        field: 'med',\n                        value: this.quartiles[1]\n                    },\n                    {\n                        field: 'uq',\n                        value: this.quartiles[2]\n                    }\n                ];\n                if (this.loutlier !== undefined) {\n                    result.push({\n                        field: 'lo',\n                        value: this.loutlier\n                    });\n                }\n                if (this.routlier !== undefined) {\n                    result.push({\n                        field: 'ro',\n                        value: this.routlier\n                    });\n                }\n                if (this.lwhisker !== undefined) {\n                    result.push({\n                        field: 'lw',\n                        value: this.lwhisker\n                    });\n                }\n                if (this.rwhisker !== undefined) {\n                    result.push({\n                        field: 'rw',\n                        value: this.rwhisker\n                    });\n                }\n                return result;\n            },\n            render: function (el, userValues) {\n                this.init(el, userValues);\n                let target = this.target, values = this.values, vlen = values.length, options = this.options, canvasWidth = this.canvasWidth, canvasHeight = this.canvasHeight, minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'), maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'), canvasLeft = 0, lwhisker, loutlier, iqr, q1, q2, q3, rwhisker, routlier, i, size, unitSize;    // if (!box._super.render.call(this)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         //     return;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // }\n                // if (!box._super.render.call(this)) {\n                //     return;\n                // }\n                if (options.get('raw')) {\n                    if (options.get('showOutliers') && values.length > 5) {\n                        loutlier = values[0];\n                        lwhisker = values[1];\n                        q1 = values[2];\n                        q2 = values[3];\n                        q3 = values[4];\n                        rwhisker = values[5];\n                        routlier = values[6];\n                    } else {\n                        lwhisker = values[0];\n                        q1 = values[1];\n                        q2 = values[2];\n                        q3 = values[3];\n                        rwhisker = values[4];\n                    }\n                } else {\n                    values.sort(function (a, b) {\n                        return a - b;\n                    });\n                    q1 = quartile(values, 1);\n                    q2 = quartile(values, 2);\n                    q3 = quartile(values, 3);\n                    iqr = q3 - q1;\n                    if (options.get('showOutliers')) {\n                        lwhisker = rwhisker = undefined;\n                        for (i = 0; i < vlen; i++) {\n                            if (lwhisker === undefined && values[i] > q1 - iqr * options.get('outlierIQR')) {\n                                lwhisker = values[i];\n                            }\n                            if (values[i] < q3 + iqr * options.get('outlierIQR')) {\n                                rwhisker = values[i];\n                            }\n                        }\n                        loutlier = values[0];\n                        routlier = values[vlen - 1];\n                    } else {\n                        lwhisker = values[0];\n                        rwhisker = values[vlen - 1];\n                    }\n                }\n                this.quartiles = [\n                    q1,\n                    q2,\n                    q3\n                ];\n                this.lwhisker = lwhisker;\n                this.rwhisker = rwhisker;\n                this.loutlier = loutlier;\n                this.routlier = routlier;\n                unitSize = canvasWidth / (maxValue - minValue + 1);\n                if (options.get('showOutliers')) {\n                    canvasLeft = Math.ceil(options.get('spotRadius'));\n                    canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));\n                    unitSize = canvasWidth / (maxValue - minValue + 1);\n                    if (loutlier < lwhisker) {\n                        target.drawCircle((loutlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();\n                    }\n                    if (routlier > rwhisker) {\n                        target.drawCircle((routlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();\n                    }\n                }    // box\n                // box\n                target.drawRect(Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q3 - q1) * unitSize), Math.round(canvasHeight * 0.8), options.get('boxLineColor'), options.get('boxFillColor')).append();    // left whisker\n                // left whisker\n                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();\n                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();    // right whisker\n                // right whisker\n                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q3 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();\n                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();    // median line\n                // median line\n                target.drawLine(Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.9), options.get('medianColor')).append();\n                if (options.get('target')) {\n                    size = Math.ceil(options.get('spotRadius'));\n                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 - size), Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 + size), options.get('targetColor')).append();\n                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size), Math.round(canvasHeight / 2), Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size), Math.round(canvasHeight / 2), options.get('targetColor')).append();\n                }    //target.render();\n            }\n        },\n        //target.render();\n        shapeCount: 0,\n        shapes: {},\n        shapeseq: [],\n        lastShapeId: null,\n        mergedOptions: null,\n        init: function (userValues, userOptions) {\n            let extendedOptions, defaults, base;\n            userOptions = userOptions || {};\n            let _this = this;\n            defaults = this.defaultOption;\n            base = defaults.common;\n            extendedOptions = defaults[userOptions.type || base.type];\n            _this.shapeCount = 0;\n            _this.shapes = {};\n            _this.shapeseq = [];\n            _this.lastShapeId = null;\n            _this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);\n            _this.mergedOptions.width = _this.mergedOptions.width;\n            _this.mergedOptions.height = _this.mergedOptions.height;\n            _this[_this.mergedOptions.type].render(_this, userValues);\n            return {\n                shapes: _this.shapes,\n                shapeseq: _this.shapeseq,\n                offsetX: _this.mergedOptions.offsetX,\n                offsetY: _this.mergedOptions.offsetY,\n                pixelWidth: _this.mergedOptions.width,\n                pixelHeight: _this.mergedOptions.height\n            };\n        },\n        _getContext: function (lineColor, fillColor, lineWidth) {\n            let context;\n            if (this.ctx != null) {\n                context = this.ctx;\n            } else {\n                context = $('#' + this._canvasID).get(0).getContext('2d');\n            }\n            if (lineColor !== undefined) {\n                context.strokeStyle = lineColor;\n            }\n            context.lineWidth = lineWidth === undefined ? 1 : lineWidth;\n            if (fillColor !== undefined) {\n                context.fillStyle = fillColor;\n            }\n            return context;\n        },\n        reset: function () {\n            let context = this._getContext();\n            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n            this.shapes = {};\n            this.shapeseq = [];\n            this.currentTargetShapeId = undefined;\n        },\n        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {\n            let context = this._getContext(lineColor, fillColor, lineWidth), i, plen;\n            context.beginPath();\n            context.moveTo(path[0][0] + 0.5 + this.offsetX, path[0][1] + 0.5 + this.offsetY);\n            for (i = 1, plen = path.length; i < plen; i++) {\n                context.lineTo(path[i][0] + 0.5 + this.offsetX, path[i][1] + 0.5 + this.offsetY);    // the 0.5 offset gives us crisp pixel-width lines\n            }\n            // the 0.5 offset gives us crisp pixel-width lines\n            if (lineColor !== undefined) {\n                context.stroke();\n            }\n            if (fillColor !== undefined) {\n                context.fill();\n            }\n            if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX + this.offsetX, this.targetY + this.offsetY)) {\n                this.currentTargetShapeId = shapeid;\n            }\n        },\n        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n            let context = this._getContext(lineColor, fillColor, lineWidth);\n            context.beginPath();\n            x += this.offsetX;\n            y += this.offsetY;\n            context.arc(x, y, radius, 0, 2 * Math.PI, false);\n            if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX + this.offsetX, this.targetY + this.offsetY)) {\n                this.currentTargetShapeId = shapeid;\n            }\n            if (lineColor !== undefined) {\n                context.stroke();\n            }\n            if (fillColor !== undefined) {\n                context.fill();\n            }\n        },\n        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n            let context = this._getContext(lineColor, fillColor);\n            x += this.offsetX;\n            y += this.offsetY;\n            context.beginPath();\n            context.moveTo(x, y);\n            context.arc(x, y, radius, startAngle, endAngle, false);\n            context.lineTo(x, y);\n            context.closePath();\n            if (lineColor !== undefined) {\n                context.stroke();\n            }\n            if (fillColor) {\n                context.fill();\n            }\n            if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX + this.offsetX, this.targetY + this.offsetY)) {\n                this.currentTargetShapeId = shapeid;\n            }\n        },\n        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {\n            // x+=this.offsetX;\n            // y+=this.offsetY;\n            return this._drawShape(shapeid, [\n                [\n                    x,\n                    y\n                ],\n                [\n                    x + width,\n                    y\n                ],\n                [\n                    x + width,\n                    y + height\n                ],\n                [\n                    x,\n                    y + height\n                ],\n                [\n                    x,\n                    y\n                ]\n            ], lineColor, fillColor);\n        },\n        appendShape: function (shape) {\n            this.shapes[shape.id] = shape;\n            this.shapeseq.push(shape.id);\n            this.lastShapeId = shape.id;\n            return shape.id;\n        },\n        replaceWithShape: function (shapeid, shape) {\n            let shapeseq = this.shapeseq, i;\n            this.shapes[shape.id] = shape;\n            for (i = shapeseq.length; i--;) {\n                if (shapeseq[i] == shapeid) {\n                    shapeseq[i] = shape.id;\n                }\n            }\n            delete this.shapes[shapeid];\n        },\n        replaceWithShapes: function (shapeids, shapes) {\n            let shapeseq = this.shapeseq, shapemap = {}, sid, i, first;\n            for (i = shapeids.length; i--;) {\n                shapemap[shapeids[i]] = true;\n            }\n            for (i = shapeseq.length; i--;) {\n                sid = shapeseq[i];\n                if (shapemap[sid]) {\n                    shapeseq.splice(i, 1);\n                    delete this.shapes[sid];\n                    first = i;\n                }\n            }\n            for (i = shapes.length; i--;) {\n                shapeseq.splice(first, 0, shapes[i].id);\n                this.shapes[shapes[i].id] = shapes[i];\n            }\n        },\n        insertAfterShape: function (shapeid, shape) {\n            let shapeseq = this.shapeseq, i;\n            for (i = shapeseq.length; i--;) {\n                if (shapeseq[i] === shapeid) {\n                    shapeseq.splice(i + 1, 0, shape.id);\n                    this.shapes[shape.id] = shape;\n                    return;\n                }\n            }\n        },\n        removeShapeId: function (shapeid) {\n            let shapeseq = this.shapeseq, i;\n            for (i = shapeseq.length; i--;) {\n                if (shapeseq[i] === shapeid) {\n                    shapeseq.splice(i, 1);\n                    break;\n                }\n            }\n            delete this.shapes[shapeid];\n        },\n        getShapeAt: function (el, x, y) {\n            this.targetX = x;\n            this.targetY = y;\n            this.render();\n            return this.currentTargetShapeId;\n        },\n        _canvasID: 'luckysheetTableContent',\n        render: function (shapeseq, shapes, offsetX, offsetY, pixelWidth, pixelHeight, canvasid, ctx) {\n            if (canvasid == null) {\n                canvasid = 'luckysheetTableContent';\n            }\n            this._canvasID = canvasid;\n            if (ctx != null) {\n                this.ctx = ctx;\n            }\n            let shapeCount = shapeseq.length, context = this._getContext(), shapeid, shape, i;\n            this.offsetX = offsetX;\n            this.offsetY = offsetY;\n            this.pixelWidth = pixelWidth;\n            this.pixelHeight = pixelHeight;    //context.clearRect(this.offsetX, this.offsetY, this.pixelWidth, this.pixelHeight);\n                                               // qkSparkSetting.currentSparkVlaue = {\n                                               //     shapeseq : shapeseq,\n                                               //     shapes:shapes,\n                                               //     shapeCount:shapeCount,\n                                               //     el:this\n                                               // }\n            //context.clearRect(this.offsetX, this.offsetY, this.pixelWidth, this.pixelHeight);\n            // qkSparkSetting.currentSparkVlaue = {\n            //     shapeseq : shapeseq,\n            //     shapes:shapes,\n            //     shapeCount:shapeCount,\n            //     el:this\n            // }\n            for (i = 0; i < shapeCount; i++) {\n                shapeid = shapeseq[i];\n                shape = shapes[shapeid];\n                this['_draw' + shape.type].apply(this, shape.args);\n            }    // if (!this.interact) {\n                 //     // not interactive so no need to keep the shapes array\n                 //     this.shapes = {};\n                 //     this.shapeseq = [];\n                 // }\n        },\n        // if (!this.interact) {\n        //     // not interactive so no need to keep the shapes array\n        //     this.shapes = {};\n        //     this.shapeseq = [];\n        // }\n        drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {\n            return this.drawShape([\n                [\n                    x1,\n                    y1\n                ],\n                [\n                    x2,\n                    y2\n                ]\n            ], lineColor, lineWidth);\n        },\n        drawShape: function (path, lineColor, fillColor, lineWidth) {\n            return this._genShape('Shape', [\n                path,\n                lineColor,\n                fillColor,\n                lineWidth\n            ]);\n        },\n        drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {\n            return this._genShape('Circle', [\n                x,\n                y,\n                radius,\n                lineColor,\n                fillColor,\n                lineWidth\n            ]);\n        },\n        drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n            return this._genShape('PieSlice', [\n                x,\n                y,\n                radius,\n                startAngle,\n                endAngle,\n                lineColor,\n                fillColor\n            ]);\n        },\n        drawRect: function (x, y, width, height, lineColor, fillColor) {\n            return this._genShape('Rect', [\n                x,\n                y,\n                width,\n                height,\n                lineColor,\n                fillColor\n            ]);\n        },\n        _genShape: function (shapetype, shapeargs) {\n            let id = this.shapeCount++;\n            shapeargs.unshift(id);    // return new VShape(this, id, shapetype, shapeargs);\n                                      // this.target = target;\n                                      // this.id = id;\n                                      // this.type = type;\n                                      // this.args = args;\n            // return new VShape(this, id, shapetype, shapeargs);\n            // this.target = target;\n            // this.id = id;\n            // this.type = type;\n            // this.args = args;\n            let shape = {\n                id: id,\n                type: shapetype,\n                args: shapeargs\n            };\n            this.shapes[id] = shape;\n            this.shapeseq.push(id);\n            this.lastShapeId = id;\n            return {\n                append: function () {\n                    return shape;\n                },\n                get: function () {\n                    return id;\n                }\n            };\n        }\n    };\n    let barHighlightMixin = {\n        changeHighlight: function (highlight) {\n            let currentRegion = this.currentRegion, target = this.target, shapeids = this.regionShapes[currentRegion], newShapes;    // will be null if the region value was null\n            // will be null if the region value was null\n            if (shapeids) {\n                newShapes = this.renderRegion(currentRegion, highlight);\n                if ($.isArray(newShapes) || $.isArray(shapeids)) {\n                    target.replaceWithShapes(shapeids, newShapes);\n                    this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {\n                        return newShape.id;\n                    });\n                } else {\n                    target.replaceWithShape(shapeids, newShapes);\n                    this.regionShapes[currentRegion] = newShapes.id;\n                }\n            }\n        },\n        render: function (el, userValues) {\n            this.init(el, userValues);\n            let values = this.values, target = this.target, regionShapes = this.regionShapes, shapes, ids, i, j;    // if (!this.cls._super.render.call(this)) {\n                                                                                                                    //     return;\n                                                                                                                    // }\n            // if (!this.cls._super.render.call(this)) {\n            //     return;\n            // }\n            for (i = values.length; i--;) {\n                shapes = this.renderRegion(i);\n                if (shapes) {\n                    if ($.isArray(shapes)) {\n                        ids = [];\n                        for (j = shapes.length; j--;) {\n                            shapes[j].append();\n                            ids.push(shapes[j].id);\n                        }\n                        regionShapes[i] = ids;\n                    } else {\n                        shapes.append();\n                        regionShapes[i] = shapes.id;    // store just the shapeid\n                    }\n                } else\n                    // store just the shapeid\n                    {\n                        // null value\n                        regionShapes[i] = null;\n                    }\n            }    //target.render();\n        }\n    };\n    //target.render();\n    let _luckysheetSparkLineOptions = {\n        get: function (type) {\n            return luckysheetSparkline.mergedOptions[type];\n        }\n    };\n    let _luckysheetSparkLineTarget = {\n        drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {\n            return luckysheetSparkline.drawLine(x1, y1, x2, y2, lineColor, lineWidth);\n        },\n        drawShape: function (path, lineColor, fillColor, lineWidth) {\n            return luckysheetSparkline.drawShape(path, lineColor, fillColor, lineWidth);\n        },\n        drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {\n            return luckysheetSparkline.drawCircle(x, y, radius, lineColor, fillColor, lineWidth);\n        },\n        drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n            return luckysheetSparkline.drawPieSlice(x, y, radius, startAngle, endAngle, lineColor, fillColor);\n        },\n        drawRect: function (x, y, width, height, lineColor, fillColor) {\n            return luckysheetSparkline.drawRect(x, y, width, height, lineColor, fillColor);\n        }\n    };\n    for (let item in luckysheetSparkline) {\n        if (item in {\n                'line': null,\n                'bar': null,\n                'column': null,\n                'tristate': null,\n                'discrete': null,\n                'bullet': null,\n                'pie': null,\n                'box': null\n            }) {\n            luckysheetSparkline[item].options = _luckysheetSparkLineOptions;\n            luckysheetSparkline[item].target = _luckysheetSparkLineTarget;\n        }\n        if (item in {\n                'bar': null,\n                'column': null,\n                'tristate': null,\n                'discrete': null\n            }) {\n            luckysheetSparkline[item].changeHighlight = barHighlightMixin.changeHighlight;\n            luckysheetSparkline[item].render = barHighlightMixin.render;\n        }\n    }\n    return luckysheetSparkline;\n});"]}