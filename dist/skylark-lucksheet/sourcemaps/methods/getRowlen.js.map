{"version":3,"sources":["methods/getRowlen.js"],"names":["define","m_util","cells","m_getdata","m_location","m_validate","Store","luckysheetfontformat","getcellvalue","checkstatusByCell","isInlineStringCell","colLocationByIndex","hasChinaword","isRealNull","checkWordByteLength","getMeasureText","value","ctx","fontset","mtc","measureTextCache","font","measureText","cache","width","actualBoundingBoxDescent","actualBoundingBoxAscent","isNaN","commonWord","oneLineTextHeight","getTextSize","textBaseline","descText","matchText","descTextMeasure","matchTextMeasure","zoomRatio","getCellTextInfo","cell","option","cellWidth","cellHeight","isMode","isModeSplit","textInfo","measureTextCellInfoCache","r","c","space_width","space_height","horizonAlign","verticalAlign","tb","tr","rt","isRotateUp","isRotateDown","parseInt","textAlign","textContent","values","cancelLine","underLine","fontSize","isInline","inlineStringArr","sharedStrings","ct","s","similarIndex","i","length","shareCell","scfontset","fc","cl","un","v","fs","splitArr","replace","split","x","newValue","push","wrap","newValueArray","n","nv","si","Object","m","textW_all","textH_all","colIndex","textH_all_cache","textH_all_Column","textH_all_ColumnHeight","preShareCell","showValue","textW","textH","item","content","style","height","left","top","asc","desc","inline","console","log","textHeight","vArr","toString","oneWordWidth","textH_all_ColumWidth","columnHeight","col","colMaxW","word","Math","max","type","textWidthAll","textHeightAll","cumColumnWidth","columnWidth","cumWordHeight","drawLineInfo","supportBoundBox","isSupportBoundingBox","textW_all_inner","splitIndex","text_all_split","rotate","abs","preStr","preTextHeight","preTextWidth","preMeasureText","anchor","spaceOrTwoByte","spaceOrTwoByteIndex","shareCells","slice","sc","textWidth","cos","PI","sin","lastWord","str","substring","substr","index","split_all_size","oneLinemaxWordCount","splitLen","keys","splitLists","sWidth","sHeight","maxDesc","maxAsc","lineHeight","maxWordCount","sp","wordCount","rtPI","lastLine","lastLineSpaceHeight","rw","rh","fixOneLineLeft","tan","size","wordGroup","y","textLeftAll","textTopAll","startX","startY","endX","endY","rowlenByRange","d","r1","r2","cfg","cfg_clone","$","extend","canvas","get","getContext","currentRowLen","defaultrowlen","mc","computeRowlen","computeRowlenArr","rowHeight","rowlenArr","rh_height","rowlen","getCellTextSplitArr","strValue","strArr","strI","strV"],"mappings":"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","file":"../../methods/getRowlen.js","sourcesContent":["define([\n    '../utils/util',\n    './cells',\n    './getdata',\n    './location',\n    './validate',\n    '../store'\n], function (m_util, cells, m_getdata, m_location, m_validate, Store) {\n    'use strict';\n    const {luckysheetfontformat} = m_util;\n    const {getcellvalue} = m_getdata;\n    const {checkstatusByCell,isInlineStringCell} = cells;\n    const {colLocationByIndex} = m_location;\n    const {hasChinaword, isRealNull, checkWordByteLength} = m_validate;\n\n    //计算范围行高\n    function rowlenByRange(d, r1, r2, cfg) {\n        let cfg_clone = $.extend(true, {}, cfg);\n        if (cfg_clone['rowlen'] == null) {\n            cfg_clone['rowlen'] = {};\n        }\n        if (cfg_clone['customHeight'] == null) {\n            cfg_clone['customHeight'] = {};\n        }\n        let canvas = $('#luckysheetTableContent').get(0).getContext('2d');\n        canvas.textBaseline = 'top';    //textBaseline以top计算\n        //textBaseline以top计算\n        for (let r = r1; r <= r2; r++) {\n            if (cfg_clone['rowhidden'] != null && cfg_clone['rowhidden'][r] != null) {\n                continue;\n            }\n            let currentRowLen = Store.defaultrowlen;\n            if (cfg_clone['customHeight'][r] == 1) {\n                continue;\n            }\n            delete cfg_clone['rowlen'][r];\n            for (let c = 0; c < d[r].length; c++) {\n                let cell = d[r][c];\n                if (cell == null || cell.mc != null) {\n                    continue;\n                }\n                if (cell != null && (cell.v != null || isInlineStringCell(cell))) {\n                    let cellWidth = colLocationByIndex(c)[1] - colLocationByIndex(c)[0] - 2;\n                    let textInfo = getCellTextInfo(cell, canvas, {\n                        r: r,\n                        c: c,\n                        cellWidth: cellWidth\n                    });\n                    let computeRowlen = 0;\n                    if (textInfo != null) {\n                        computeRowlen = textInfo.textHeightAll + 2;\n                    }    //比较计算高度和当前高度取最大高度\n                    //比较计算高度和当前高度取最大高度\n                    if (computeRowlen > currentRowLen) {\n                        currentRowLen = computeRowlen;\n                    }\n                }\n            }\n            currentRowLen = currentRowLen / Store.zoomRatio;\n            if (currentRowLen != Store.defaultrowlen) {\n                cfg_clone['rowlen'][r] = currentRowLen;\n            }\n        }\n        return cfg_clone;\n    }    //计算表格行高数组\n    //计算表格行高数组\n    function computeRowlenArr(rowHeight, cfg) {\n        let rowlenArr = [];\n        let rh_height = 0;\n        for (let i = 0; i < rowHeight; i++) {\n            let rowlen = Store.defaultrowlen;\n            if (cfg['rowlen'] != null && cfg['rowlen'][i] != null) {\n                rowlen = cfg['rowlen'][i];\n            }\n            if (cfg['rowhidden'] != null && cfg['rowhidden'][i] != null) {\n                rowlen = cfg['rowhidden'][i];\n                rowlenArr.push(rh_height);\n                continue;\n            } else {\n                rh_height += rowlen + 1;\n            }\n            rowlenArr.push(rh_height);    //行的临时长度分布\n        }\n        //行的临时长度分布\n        return rowlenArr;\n    }    //获取换行单元格截断数组\n    //获取换行单元格截断数组\n    function getCellTextSplitArr(strValue, strArr, cellWidth, canvas) {\n        for (let strI = 1; strI <= strValue.length; strI++) {\n            let strV = strValue.substring(0, strI);\n            let strtextMetrics = getMeasureText(strV, canvas).width;\n            if (strtextMetrics > cellWidth) {\n                if (strI - 1 <= 0) {\n                    return strArr;\n                } else {\n                    strArr.push(strValue.substring(0, strI - 1));\n                    return getCellTextSplitArr(strValue.substring(strI - 1), strArr, cellWidth, canvas);\n                }\n            } else if (strI == strValue.length) {\n                strArr.push(strV);\n            }\n        }\n        return strArr;\n    }    //获取有值单元格文本大小\n         // let measureTextCache = {}, measureTextCacheTimeOut = null;\n    //获取有值单元格文本大小\n    // let measureTextCache = {}, measureTextCacheTimeOut = null;\n    function getMeasureText(value, ctx, fontset) {\n        let mtc = Store.measureTextCache[value + '_' + ctx.font];\n        if (fontset != null) {\n            mtc = Store.measureTextCache[value + '_' + fontset];\n        }\n        if (mtc != null) {\n            return mtc;\n        } else {\n            if (fontset != null) {\n                let preFont = ctx.font;\n                ctx.font = fontset;\n            }\n            let measureText = ctx.measureText(value), cache = {};    // var regu = \"^[ ]+$\";\n                                                                     // var re = new RegExp(regu);\n                                                                     // if(measureText.actualBoundingBoxRight==null || re.test(value)){\n                                                                     //     cache.width = measureText.width;\n                                                                     // }\n                                                                     // else{\n                                                                     //     //measureText.actualBoundingBoxLeft +\n                                                                     //     cache.width = measureText.actualBoundingBoxRight;\n                                                                     // }\n            // var regu = \"^[ ]+$\";\n            // var re = new RegExp(regu);\n            // if(measureText.actualBoundingBoxRight==null || re.test(value)){\n            //     cache.width = measureText.width;\n            // }\n            // else{\n            //     //measureText.actualBoundingBoxLeft +\n            //     cache.width = measureText.actualBoundingBoxRight;\n            // }\n            cache.width = measureText.width;\n            if (fontset != null) {\n                ctx.font = fontset;\n            }\n            cache.actualBoundingBoxDescent = measureText.actualBoundingBoxDescent;\n            cache.actualBoundingBoxAscent = measureText.actualBoundingBoxAscent;\n            if (cache.actualBoundingBoxDescent == null || cache.actualBoundingBoxAscent == null || isNaN(cache.actualBoundingBoxDescent) || isNaN(cache.actualBoundingBoxAscent)) {\n                let commonWord = 'M';\n                if (hasChinaword(value)) {\n                    commonWord = '田';\n                }\n                let oneLineTextHeight = cells.getTextSize(commonWord, ctx.font)[1] * 0.8;\n                if (ctx.textBaseline == 'top') {\n                    cache.actualBoundingBoxDescent = oneLineTextHeight;\n                    cache.actualBoundingBoxAscent = 0;\n                } else if (ctx.textBaseline == 'middle') {\n                    cache.actualBoundingBoxDescent = oneLineTextHeight / 2;\n                    cache.actualBoundingBoxAscent = oneLineTextHeight / 2;\n                } else {\n                    cache.actualBoundingBoxDescent = 0;\n                    cache.actualBoundingBoxAscent = oneLineTextHeight;\n                }    //console.log(value, oneLineTextHeight, measureText.actualBoundingBoxDescent+measureText.actualBoundingBoxAscent,ctx.font);\n            }\n            //console.log(value, oneLineTextHeight, measureText.actualBoundingBoxDescent+measureText.actualBoundingBoxAscent,ctx.font);\n            if (ctx.textBaseline == 'alphabetic') {\n                let descText = 'gjpqy', matchText = 'abcdABCD';\n                let descTextMeasure = Store.measureTextCache[descText + '_' + ctx.font];\n                if (fontset != null) {\n                    descTextMeasure = Store.measureTextCache[descText + '_' + fontset];\n                }\n                let matchTextMeasure = Store.measureTextCache[matchText + '_' + ctx.font];\n                if (fontset != null) {\n                    matchTextMeasure = Store.measureTextCache[matchText + '_' + fontset];\n                }\n                if (descTextMeasure == null) {\n                    descTextMeasure = ctx.measureText(descText);\n                }\n                if (matchTextMeasure == null) {\n                    matchTextMeasure = ctx.measureText(matchText);\n                }\n                if (cache.actualBoundingBoxDescent <= matchTextMeasure.actualBoundingBoxDescent) {\n                    cache.actualBoundingBoxDescent = descTextMeasure.actualBoundingBoxDescent;\n                    if (cache.actualBoundingBoxDescent == null) {\n                        cache.actualBoundingBoxDescent = 0;\n                    }\n                }\n            }\n            cache.width *= Store.zoomRatio;\n            cache.actualBoundingBoxDescent *= Store.zoomRatio;\n            cache.actualBoundingBoxAscent *= Store.zoomRatio;\n            Store.measureTextCache[value + '_' + Store.zoomRatio + '_' + ctx.font] = cache;    // console.log(measureText, value);\n            // console.log(measureText, value);\n            return cache;\n        }\n    }\n    function isSupportBoundingBox(ctx) {\n        let measureText = ctx.measureText('田');\n        if (measureText.actualBoundingBoxAscent == null) {\n            return false;\n        }\n        return true;\n    }    //获取单元格文本内容的渲染信息\n         // let measureTextCache = {}, measureTextCacheTimeOut = null;\n         // option {cellWidth,cellHeight,space_width,space_height}\n    //获取单元格文本内容的渲染信息\n    // let measureTextCache = {}, measureTextCacheTimeOut = null;\n    // option {cellWidth,cellHeight,space_width,space_height}\n    function getCellTextInfo(cell, ctx, option) {\n        let cellWidth = option.cellWidth;\n        let cellHeight = option.cellHeight;\n        let isMode = '', isModeSplit = '';    // console.log(\"initialinfo\", cell, option);\n        // console.log(\"initialinfo\", cell, option);\n        if (cellWidth == null) {\n            isMode = 'onlyWidth';\n            isModeSplit = '_';\n        }\n        let textInfo = Store.measureTextCellInfoCache[option.r + '_' + option.c + isModeSplit + isMode];\n        if (textInfo != null) {\n            return textInfo;\n        }    // let cell = Store.flowdata[r][c];\n        // let cell = Store.flowdata[r][c];\n        let space_width = option.space_width, space_height = option.space_height;    //宽高方向 间隙\n        //宽高方向 间隙\n        if (space_width == null) {\n            space_width = 2;\n        }\n        if (space_height == null) {\n            space_height = 2;\n        }    //水平对齐\n        //水平对齐\n        let horizonAlign = checkstatusByCell(cell, 'ht');    //垂直对齐\n        //垂直对齐\n        let verticalAlign = checkstatusByCell(cell, 'vt');\n        let tb = checkstatusByCell(cell, 'tb');    //wrap overflow\n        //wrap overflow\n        let tr = checkstatusByCell(cell, 'tr');    //rotate\n        //rotate\n        let rt = checkstatusByCell(cell, 'rt');    //rotate angle\n        //rotate angle\n        let isRotateUp = 1, isRotateDown = 0;\n        if (rt == null) {\n            if (tr == '0') {\n                rt = 0;\n            } else if (tr == '1') {\n                rt = 45;\n            } else if (tr == '4') {\n                rt = 90;\n            } else if (tr == '2') {\n                rt = 135;\n            } else if (tr == '5') {\n                rt = 180;\n            }\n            if (rt == null) {\n                rt = 0;\n            }\n        }\n        if (rt > 180 || rt < 0) {\n            rt = 0;\n        }\n        rt = parseInt(rt);\n        if (rt > 90) {\n            rt = 90 - rt;\n            isRotateUp = 0;\n            isRotateDown = 1;\n        }\n        ctx.textAlign = 'start';\n        let textContent = {};\n        textContent.values = [];\n        let fontset, cancelLine = '0', underLine = '0', fontSize = 11, isInline = false, value, inlineStringArr = [];\n        if (isInlineStringCell(cell)) {\n            let sharedStrings = cell.ct.s, similarIndex = 0;\n            for (let i = 0; i < sharedStrings.length; i++) {\n                let shareCell = sharedStrings[i];\n                let scfontset = luckysheetfontformat(shareCell);\n                let fc = shareCell.fc, cl = shareCell.cl, un = shareCell.un, v = shareCell.v, fs = shareCell.fs;\n                v = v.replace(/\\r\\n/g, '_x000D_').replace(/&#13;&#10;/g, '_x000D_').replace(/\\r/g, '_x000D_').replace(/\\n/g, '_x000D_');\n                let splitArr = v.split('_x000D_');\n                for (let x = 0; x < splitArr.length; x++) {\n                    let newValue = splitArr[x];\n                    if (newValue == '' && x != splitArr.length - 1) {\n                        inlineStringArr.push({\n                            fontset: scfontset,\n                            fc: fc == null ? '#000' : fc,\n                            cl: cl == null ? 0 : cl,\n                            un: un == null ? 0 : un,\n                            wrap: true,\n                            fs: fs == null ? 11 : fs\n                        });\n                        similarIndex++;\n                    } else {\n                        let newValueArray = newValue.split('');\n                        for (let n = 0; n < newValueArray.length; n++) {\n                            let nv = newValueArray[n];\n                            inlineStringArr.push({\n                                fontset: scfontset,\n                                fc: fc == null ? '#000' : fc,\n                                cl: cl == null ? 0 : cl,\n                                un: un == null ? 0 : un,\n                                v: nv,\n                                si: similarIndex,\n                                fs: fs == null ? 11 : fs\n                            });\n                        }\n                        if (x != splitArr.length - 1) {\n                            inlineStringArr.push({\n                                fontset: scfontset,\n                                fc: fc == null ? '#000' : fc,\n                                cl: cl == null ? 0 : cl,\n                                un: un == null ? 0 : un,\n                                wrap: true,\n                                fs: fs == null ? 11 : fs\n                            });\n                            similarIndex++;\n                        }\n                    }\n                }\n                similarIndex++;\n            }\n            isInline = true;\n        } else {\n            fontset = luckysheetfontformat(cell);\n            ctx.font = fontset;\n            cancelLine = checkstatusByCell(cell, 'cl');    //cancelLine\n            //cancelLine\n            underLine = checkstatusByCell(cell, 'un');    //underLine\n            //underLine\n            fontSize = checkstatusByCell(cell, 'fs');\n            if (cell instanceof Object) {\n                value = cell.m;\n                if (value == null) {\n                    value = cell.v;\n                }\n            } else {\n                value = cell;\n            }\n            if (isRealNull(value)) {\n                return null;\n            }\n        }    // let measureText = getMeasureText(value, ctx);\n             // //luckysheetTableContent.measureText(value);\n             // let textWidth = measureText.width;\n             // let textHeight = measureText.actualBoundingBoxDescent + measureText.actualBoundingBoxAscent;\n        // let measureText = getMeasureText(value, ctx);\n        // //luckysheetTableContent.measureText(value);\n        // let textWidth = measureText.width;\n        // let textHeight = measureText.actualBoundingBoxDescent + measureText.actualBoundingBoxAscent;\n        if (tr == '3') {\n            //vertical text\n            ctx.textBaseline = 'top';\n            let textW_all = 0;    //拆分后宽高度合计\n            //拆分后宽高度合计\n            let textH_all = 0;\n            let colIndex = 0, textH_all_cache = 0, textH_all_Column = {}, textH_all_ColumnHeight = [];\n            if (isInline) {\n                let preShareCell = null;\n                for (let i = 0; i < inlineStringArr.length; i++) {\n                    let shareCell = inlineStringArr[i];\n                    let value = shareCell.v, showValue = shareCell.v;\n                    if (shareCell.wrap === true) {\n                        value = 'M';\n                        showValue = '';\n                        if (preShareCell != null && preShareCell.wrap !== true && i < inlineStringArr.length - 1) {\n                            // console.log(\"wrap\",i,colIndex,preShareCell.wrap);\n                            textH_all_ColumnHeight.push(textH_all_cache);\n                            textH_all_cache = 0;\n                            colIndex += 1;\n                            preShareCell = shareCell;\n                            continue;\n                        }\n                    }\n                    let measureText = getMeasureText(value, ctx, shareCell.fontset);\n                    let textW = measureText.width + space_width;\n                    let textH = measureText.actualBoundingBoxAscent + measureText.actualBoundingBoxDescent + space_height;    // textW_all += textW;\n                    // textW_all += textW;\n                    textH_all_cache += textH;\n                    if (tb == '2' && !shareCell.wrap) {\n                        if (textH_all_cache > cellHeight && textH_all_Column[colIndex] != null) {\n                            // textW_all += textW;\n                            // textH_all = Math.max(textH_all,textH_all_cache);\n                            // console.log(\">\",i,colIndex);\n                            textH_all_ColumnHeight.push(textH_all_cache - textH);\n                            textH_all_cache = textH;\n                            colIndex += 1;\n                        }\n                    }\n                    if (i == inlineStringArr.length - 1) {\n                        textH_all_ColumnHeight.push(textH_all_cache);\n                    }\n                    if (textH_all_Column[colIndex] == null) {\n                        textH_all_Column[colIndex] = [];\n                    }\n                    let item = {\n                        content: showValue,\n                        style: shareCell,\n                        width: textW,\n                        height: textH,\n                        left: 0,\n                        top: 0,\n                        colIndex: colIndex,\n                        asc: measureText.actualBoundingBoxAscent,\n                        desc: measureText.actualBoundingBoxDescent,\n                        inline: true\n                    };\n                    if (shareCell.wrap === true) {\n                        item.wrap = true;\n                    }\n                    textH_all_Column[colIndex].push(item);\n                    console.log('normal', i, colIndex, shareCell, preShareCell, textH_all_Column);\n                    preShareCell = shareCell;\n                }\n            } else {\n                let measureText = getMeasureText(value, ctx);\n                let textHeight = measureText.actualBoundingBoxDescent + measureText.actualBoundingBoxAscent;\n                value = value.toString();\n                let vArr = [];\n                if (value.length > 1) {\n                    vArr = value.split('');\n                } else {\n                    vArr.push(value);\n                }\n                let oneWordWidth = getMeasureText(vArr[0], ctx).width;\n                for (let i = 0; i < vArr.length; i++) {\n                    let textW = oneWordWidth + space_width;\n                    let textH = textHeight + space_height;    // textW_all += textW;\n                    // textW_all += textW;\n                    textH_all_cache += textH;\n                    if (tb == '2') {\n                        if (textH_all_cache > cellHeight && textH_all_Column[colIndex] != null) {\n                            // textW_all += textW;\n                            // textH_all = Math.max(textH_all,textH_all_cache);\n                            textH_all_ColumnHeight.push(textH_all_cache - textH);\n                            textH_all_cache = textH;\n                            colIndex += 1;\n                        }\n                    }\n                    if (i == vArr.length - 1) {\n                        textH_all_ColumnHeight.push(textH_all_cache);\n                    }\n                    if (textH_all_Column[colIndex] == null) {\n                        textH_all_Column[colIndex] = [];\n                    }\n                    textH_all_Column[colIndex].push({\n                        content: vArr[i],\n                        style: fontset,\n                        width: textW,\n                        height: textH,\n                        left: 0,\n                        top: 0,\n                        colIndex: colIndex,\n                        asc: measureText.actualBoundingBoxAscent,\n                        desc: measureText.actualBoundingBoxDescent\n                    });\n                }\n            }\n            let textH_all_ColumWidth = [];\n            for (let i = 0; i < textH_all_ColumnHeight.length; i++) {\n                let columnHeight = textH_all_ColumnHeight[i];\n                let col = textH_all_Column[i], colMaxW = 0;\n                for (let c = 0; c < col.length; c++) {\n                    let word = col[c];\n                    colMaxW = Math.max(colMaxW, word.width);\n                }\n                textH_all_ColumWidth.push(colMaxW);\n                textW_all += colMaxW;\n                textH_all = Math.max(textH_all, columnHeight);\n            }\n            textContent.type = 'verticalWrap';\n            textContent.textWidthAll = textW_all;\n            textContent.textHeightAll = textH_all;\n            if (isMode == 'onlyWidth') {\n                // console.log(\"verticalWrap\", textContent,cell, option);\n                return textContent;\n            }\n            let cumColumnWidth = 0;\n            for (let i = 0; i < textH_all_ColumnHeight.length; i++) {\n                let columnHeight = textH_all_ColumnHeight[i];\n                let columnWidth = textH_all_ColumWidth[i];\n                let col = textH_all_Column[i];\n                let cumWordHeight = 0;\n                for (let c = 0; c < col.length; c++) {\n                    let word = col[c];\n                    let left = space_width + cumColumnWidth;\n                    if (horizonAlign == '0') {\n                        left = cellWidth / 2 + cumColumnWidth - textW_all / 2 + space_width * textH_all_ColumnHeight.length;\n                    } else if (horizonAlign == '2') {\n                        left = cellWidth + cumColumnWidth - textW_all + space_width;\n                    }\n                    let top = cellHeight - space_height + cumWordHeight - columnHeight;\n                    if (verticalAlign == '0') {\n                        top = cellHeight / 2 + cumWordHeight - columnHeight / 2;\n                    } else if (verticalAlign == '1') {\n                        top = space_height + cumWordHeight;\n                    }\n                    cumWordHeight += word.height;\n                    word.left = left;\n                    word.top = top;\n                    drawLineInfo(word, cancelLine, underLine, {\n                        width: columnWidth,\n                        height: word.height,\n                        left: left,\n                        top: top + word.height - space_height,\n                        asc: word.height,\n                        desc: 0,\n                        fs: fontSize\n                    });\n                    textContent.values.push(word);\n                }\n                cumColumnWidth += columnWidth;\n            }\n        } else {\n            let supportBoundBox = isSupportBoundingBox(ctx);\n            if (supportBoundBox) {\n                ctx.textBaseline = 'alphabetic';\n            } else {\n                ctx.textBaseline = 'bottom';\n            }\n            if (tb == '2' || isInline) {\n                //wrap\n                let textW_all = 0;    //拆分后宽高度合计\n                //拆分后宽高度合计\n                let textH_all = 0;\n                let textW_all_inner = 0;    // let oneWordWidth =  getMeasureText(vArr[0], ctx).width;\n                // let oneWordWidth =  getMeasureText(vArr[0], ctx).width;\n                let splitIndex = 0, text_all_cache = 0, text_all_split = {}, text_all_splitLen = [];\n                textContent.rotate = rt;\n                rt = Math.abs(rt);\n                let anchor = 0, preHeight = 0, preWidth = 0, preStr, preTextHeight, preTextWidth, preMeasureText, i = 1, wrapStyle = {}, spaceOrTwoByte = null, spaceOrTwoByteIndex = null;\n                if (isInline) {\n                    while (i <= inlineStringArr.length) {\n                        let shareCells = inlineStringArr.slice(anchor, i);\n                        if (shareCells[shareCells.length - 1].wrap === true) {\n                            anchor = i;\n                            if (shareCells.length > 1) {\n                                for (let s = 0; s < shareCells.length - 1; s++) {\n                                    let sc = shareCells[s];\n                                    let item = {\n                                        content: sc.v,\n                                        style: sc,\n                                        width: sc.measureText.width,\n                                        height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        asc: sc.measureText.actualBoundingBoxAscent,\n                                        desc: sc.measureText.actualBoundingBoxDescent,\n                                        inline: true,\n                                        fs: sc.fs\n                                    };    // if(rt!=0){//rotate\n                                          //     item.textHeight = sc.textHeight;\n                                          //     item.textWidth = sc.textWidth;\n                                          // }\n                                    // if(rt!=0){//rotate\n                                    //     item.textHeight = sc.textHeight;\n                                    //     item.textWidth = sc.textWidth;\n                                    // }\n                                    text_all_split[splitIndex].push(item);\n                                }\n                            }\n                            if (shareCells.length == 1 || i == inlineStringArr.length) {\n                                let sc = shareCells[0];\n                                let measureText = getMeasureText('M', ctx, sc.fontset);\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                text_all_split[splitIndex].push({\n                                    content: '',\n                                    style: sc,\n                                    width: measureText.width,\n                                    height: measureText.actualBoundingBoxAscent + measureText.actualBoundingBoxDescent,\n                                    left: 0,\n                                    top: 0,\n                                    splitIndex: splitIndex,\n                                    asc: measureText.actualBoundingBoxAscent,\n                                    desc: measureText.actualBoundingBoxDescent,\n                                    inline: true,\n                                    wrap: true,\n                                    fs: sc.fs\n                                });\n                            }\n                            splitIndex += 1;\n                            i++;\n                            continue;\n                        }\n                        let textWidth = 0, textHeight = 0;\n                        for (let s = 0; s < shareCells.length; s++) {\n                            let sc = shareCells[s];\n                            if (sc.measureText == null) {\n                                sc.measureText = getMeasureText(sc.v, ctx, sc.fontset);\n                            }\n                            textWidth += sc.measureText.width;\n                            textHeight = Math.max(sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent);    // console.log(sc.v,sc.measureText.width,sc.measureText.actualBoundingBoxAscent,sc.measureText.actualBoundingBoxDescent);\n                        }\n                        // console.log(sc.v,sc.measureText.width,sc.measureText.actualBoundingBoxAscent,sc.measureText.actualBoundingBoxDescent);\n                        let width = textWidth * Math.cos(rt * Math.PI / 180) + textHeight * Math.sin(rt * Math.PI / 180);    //consider text box wdith and line height\n                        //consider text box wdith and line height\n                        let height = textWidth * Math.sin(rt * Math.PI / 180) + textHeight * Math.cos(rt * Math.PI / 180);    //consider text box wdith and line height\n                                                                                                                              // textW_all += textW;\n                        //consider text box wdith and line height\n                        // textW_all += textW;\n                        let lastWord = shareCells[shareCells.length - 1];\n                        if (lastWord.v == ' ' || checkWordByteLength(lastWord.v) == 2) {\n                            spaceOrTwoByteIndex = i;\n                        }\n                        if (rt != 0) {\n                            //rotate\n                            // console.log(\"all\",anchor, i , str);\n                            console.log(height, space_height, cellHeight, shareCells, height + space_height > cellHeight);\n                            if (height + space_height > cellHeight && text_all_split[splitIndex] != null && tb == '2' && i != inlineStringArr.length) {\n                                // console.log(\"cut\",anchor, i , str);\n                                if (spaceOrTwoByteIndex != null && spaceOrTwoByteIndex < i) {\n                                    for (let s = 0; s < spaceOrTwoByteIndex - anchor; s++) {\n                                        let sc = shareCells[s];\n                                        text_all_split[splitIndex].push({\n                                            content: sc.v,\n                                            style: sc,\n                                            width: sc.measureText.width,\n                                            height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                            left: 0,\n                                            top: 0,\n                                            splitIndex: splitIndex,\n                                            asc: sc.measureText.actualBoundingBoxAscent,\n                                            desc: sc.measureText.actualBoundingBoxDescent,\n                                            inline: true,\n                                            fs: sc.fs\n                                        });\n                                    }\n                                    anchor = spaceOrTwoByteIndex;\n                                    i = spaceOrTwoByteIndex + 1;\n                                    splitIndex += 1;\n                                    spaceOrTwoByteIndex = null;\n                                } else {\n                                    anchor = i - 1;\n                                    for (let s = 0; s < shareCells.length - 1; s++) {\n                                        let sc = shareCells[s];\n                                        text_all_split[splitIndex].push({\n                                            content: sc.v,\n                                            style: sc,\n                                            width: sc.measureText.width,\n                                            height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                            left: 0,\n                                            top: 0,\n                                            splitIndex: splitIndex,\n                                            asc: sc.measureText.actualBoundingBoxAscent,\n                                            desc: sc.measureText.actualBoundingBoxDescent,\n                                            inline: true,\n                                            fs: sc.fs\n                                        });\n                                    }\n                                    splitIndex += 1;\n                                }\n                            } else if (i == inlineStringArr.length) {\n                                // console.log(\"last\",anchor, i , str);\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                for (let s = 0; s < shareCells.length; s++) {\n                                    let sc = shareCells[s];\n                                    text_all_split[splitIndex].push({\n                                        content: sc.v,\n                                        style: sc,\n                                        width: sc.measureText.width,\n                                        height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        asc: sc.measureText.actualBoundingBoxAscent,\n                                        desc: sc.measureText.actualBoundingBoxDescent,\n                                        inline: true,\n                                        fs: sc.fs\n                                    });\n                                }\n                                break;\n                            } else {\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                i++;\n                            }\n                        } else {\n                            //plain\n                            if (width + space_width > cellWidth && text_all_split[splitIndex] != null && tb == '2' && i != inlineStringArr.length) {\n                                if (spaceOrTwoByteIndex != null && spaceOrTwoByteIndex < i) {\n                                    for (let s = 0; s < spaceOrTwoByteIndex - anchor; s++) {\n                                        let sc = shareCells[s];\n                                        text_all_split[splitIndex].push({\n                                            content: sc.v,\n                                            style: sc,\n                                            width: sc.measureText.width,\n                                            height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                            left: 0,\n                                            top: 0,\n                                            splitIndex: splitIndex,\n                                            asc: sc.measureText.actualBoundingBoxAscent,\n                                            desc: sc.measureText.actualBoundingBoxDescent,\n                                            inline: true,\n                                            fs: sc.fs\n                                        });\n                                    }\n                                    anchor = spaceOrTwoByteIndex;\n                                    i = spaceOrTwoByteIndex + 1;\n                                    splitIndex += 1;\n                                    spaceOrTwoByteIndex = null;\n                                } else {\n                                    anchor = i - 1;\n                                    for (let s = 0; s < shareCells.length - 1; s++) {\n                                        let sc = shareCells[s];\n                                        text_all_split[splitIndex].push({\n                                            content: sc.v,\n                                            style: sc,\n                                            width: sc.measureText.width,\n                                            height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                            left: 0,\n                                            top: 0,\n                                            splitIndex: splitIndex,\n                                            asc: sc.measureText.actualBoundingBoxAscent,\n                                            desc: sc.measureText.actualBoundingBoxDescent,\n                                            inline: true,\n                                            fs: sc.fs\n                                        });\n                                    }\n                                    splitIndex += 1;\n                                }\n                            } else if (i == inlineStringArr.length) {\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                for (let s = 0; s < shareCells.length; s++) {\n                                    let sc = shareCells[s];\n                                    text_all_split[splitIndex].push({\n                                        content: sc.v,\n                                        style: sc,\n                                        width: sc.measureText.width,\n                                        height: sc.measureText.actualBoundingBoxAscent + sc.measureText.actualBoundingBoxDescent,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        asc: sc.measureText.actualBoundingBoxAscent,\n                                        desc: sc.measureText.actualBoundingBoxDescent,\n                                        inline: true,\n                                        fs: sc.fs\n                                    });\n                                }\n                                break;\n                            } else {\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                i++;\n                            }\n                        }\n                    }\n                } else {\n                    value = value.toString();\n                    while (i <= value.length) {\n                        let str = value.substring(anchor, i);\n                        let measureText = getMeasureText(str, ctx);\n                        let textWidth = measureText.width;\n                        let textHeight = measureText.actualBoundingBoxAscent + measureText.actualBoundingBoxDescent;\n                        let width = textWidth * Math.cos(rt * Math.PI / 180) + textHeight * Math.sin(rt * Math.PI / 180);    //consider text box wdith and line height\n                        //consider text box wdith and line height\n                        let height = textWidth * Math.sin(rt * Math.PI / 180) + textHeight * Math.cos(rt * Math.PI / 180);    //consider text box wdith and line height\n                        //consider text box wdith and line height\n                        let lastWord = str.substr(str.length - 1, 1);\n                        if (lastWord == ' ' || checkWordByteLength(lastWord) == 2) {\n                            if (preMeasureText != null) {\n                                spaceOrTwoByte = {\n                                    index: i,\n                                    str: preStr,\n                                    width: preTextWidth,\n                                    height: preTextHeight,\n                                    asc: preMeasureText.actualBoundingBoxAscent,\n                                    desc: preMeasureText.actualBoundingBoxDescent\n                                };\n                            }\n                        }    // textW_all += textW;\n                             // console.log(str,anchor,i);\n                        // textW_all += textW;\n                        // console.log(str,anchor,i);\n                        if (rt != 0) {\n                            //rotate\n                            // console.log(\"all\",anchor, i , str);\n                            if (height + space_height > cellHeight && text_all_split[splitIndex] != null && i != value.length) {\n                                // console.log(\"cut\",anchor, i , str);\n                                if (spaceOrTwoByte != null && spaceOrTwoByte.index < i) {\n                                    anchor = spaceOrTwoByte.index;\n                                    i = spaceOrTwoByte.index + 1;\n                                    text_all_split[splitIndex].push({\n                                        content: spaceOrTwoByte.str,\n                                        style: fontset,\n                                        width: spaceOrTwoByte.width,\n                                        height: spaceOrTwoByte.height,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        asc: spaceOrTwoByte.asc,\n                                        desc: spaceOrTwoByte.desc,\n                                        fs: fontSize\n                                    });    // console.log(1,anchor,i,splitIndex , spaceOrTwoByte.str);\n                                    // console.log(1,anchor,i,splitIndex , spaceOrTwoByte.str);\n                                    splitIndex += 1;\n                                    spaceOrTwoByte = null;\n                                } else {\n                                    anchor = i - 1;\n                                    text_all_split[splitIndex].push({\n                                        content: preStr,\n                                        style: fontset,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        height: preTextHeight,\n                                        width: preTextWidth,\n                                        asc: measureText.actualBoundingBoxAscent,\n                                        desc: measureText.actualBoundingBoxDescent,\n                                        fs: fontSize\n                                    });    // console.log(2,anchor,i, splitIndex, preStr);\n                                    // console.log(2,anchor,i, splitIndex, preStr);\n                                    splitIndex += 1;\n                                }\n                            } else if (i == value.length) {\n                                // console.log(\"last\",anchor, i , str);\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                text_all_split[splitIndex].push({\n                                    content: str,\n                                    style: fontset,\n                                    left: 0,\n                                    top: 0,\n                                    splitIndex: splitIndex,\n                                    height: textHeight,\n                                    width: textWidth,\n                                    asc: measureText.actualBoundingBoxAscent,\n                                    desc: measureText.actualBoundingBoxDescent,\n                                    fs: fontSize\n                                });\n                                break;\n                            } else {\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                i++;\n                            }\n                        } else {\n                            //plain\n                            if (width + space_width > cellWidth && text_all_split[splitIndex] != null && i != value.length) {\n                                // console.log(spaceOrTwoByte, i, anchor);\n                                if (spaceOrTwoByte != null && spaceOrTwoByte.index < i) {\n                                    anchor = spaceOrTwoByte.index;\n                                    i = spaceOrTwoByte.index + 1;\n                                    text_all_split[splitIndex].push({\n                                        content: spaceOrTwoByte.str,\n                                        style: fontset,\n                                        width: spaceOrTwoByte.width,\n                                        height: spaceOrTwoByte.height,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        asc: spaceOrTwoByte.asc,\n                                        desc: spaceOrTwoByte.desc,\n                                        fs: fontSize\n                                    });\n                                    splitIndex += 1;\n                                    spaceOrTwoByte = null;\n                                } else {\n                                    spaceOrTwoByte = null;\n                                    anchor = i - 1;\n                                    text_all_split[splitIndex].push({\n                                        content: preStr,\n                                        style: fontset,\n                                        width: preTextWidth,\n                                        height: preTextHeight,\n                                        left: 0,\n                                        top: 0,\n                                        splitIndex: splitIndex,\n                                        asc: measureText.actualBoundingBoxAscent,\n                                        desc: measureText.actualBoundingBoxDescent,\n                                        fs: fontSize\n                                    });    // console.log(2);\n                                    // console.log(2);\n                                    splitIndex += 1;\n                                }\n                            } else if (i == value.length) {\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                text_all_split[splitIndex].push({\n                                    content: str,\n                                    style: fontset,\n                                    width: textWidth,\n                                    height: textHeight,\n                                    left: 0,\n                                    top: 0,\n                                    splitIndex: splitIndex,\n                                    asc: measureText.actualBoundingBoxAscent,\n                                    desc: measureText.actualBoundingBoxDescent,\n                                    fs: fontSize\n                                });\n                                break;\n                            } else {\n                                if (text_all_split[splitIndex] == null) {\n                                    text_all_split[splitIndex] = [];\n                                }\n                                i++;\n                            }\n                        }\n                        preStr = str;\n                        preTextHeight = textHeight;\n                        preTextWidth = textWidth;\n                        preMeasureText = measureText;\n                    }    // console.log(text_all_split)\n                }\n                // console.log(text_all_split)\n                let split_all_size = [], oneLinemaxWordCount = 0;    // console.log(\"split\",splitIndex, text_all_split);\n                // console.log(\"split\",splitIndex, text_all_split);\n                let splitLen = Object.keys(text_all_split).length;\n                for (let i = 0; i < splitLen; i++) {\n                    let splitLists = text_all_split[i];\n                    if (splitLists == null) {\n                        continue;\n                    }\n                    let sWidth = 0, sHeight = 0, maxDesc = 0, maxAsc = 0, lineHeight = 0, maxWordCount = 0;\n                    for (let s = 0; s < splitLists.length; s++) {\n                        let sp = splitLists[s];\n                        if (rt != 0) {\n                            //rotate\n                            sWidth += sp.width;\n                            sHeight = Math.max(sHeight, sp.height - (supportBoundBox ? sp.desc : 0));\n                        } else {\n                            //plain\n                            sWidth += sp.width;\n                            sHeight = Math.max(sHeight, sp.height - (supportBoundBox ? sp.desc : 0));\n                        }\n                        maxDesc = Math.max(maxDesc, supportBoundBox ? sp.desc : 0);\n                        maxAsc = Math.max(maxAsc, sp.asc);\n                        maxWordCount++;\n                    }\n                    lineHeight = sHeight / 2;\n                    oneLinemaxWordCount = Math.max(oneLinemaxWordCount, maxWordCount);\n                    if (rt != 0) {\n                        //rotate\n                        sHeight += lineHeight;\n                        textW_all_inner = Math.max(textW_all_inner, sWidth);    // textW_all =  Math.max(textW_all, sWidth+ (textH_all)/Math.tan(rt*Math.PI/180));\n                        // textW_all =  Math.max(textW_all, sWidth+ (textH_all)/Math.tan(rt*Math.PI/180));\n                        textH_all += sHeight;\n                    } else {\n                        //plain\n                        // console.log(\"textH_all\",textW_all, textH_all);\n                        sHeight += lineHeight;\n                        textW_all = Math.max(textW_all, sWidth);\n                        textH_all += sHeight;\n                    }\n                    split_all_size.push({\n                        width: sWidth,\n                        height: sHeight,\n                        desc: maxDesc,\n                        asc: maxAsc,\n                        lineHeight: lineHeight,\n                        wordCount: maxWordCount\n                    });\n                }    // console.log(textH_all,textW_all,textW_all_inner);\n                     // let cumColumnWidth = 0;\n                // console.log(textH_all,textW_all,textW_all_inner);\n                // let cumColumnWidth = 0;\n                let cumWordHeight = 0, cumColumnWidth = 0;\n                let rtPI = rt * Math.PI / 180;\n                let lastLine = split_all_size[splitLen - 1];\n                let lastLineSpaceHeight = lastLine.lineHeight;\n                textH_all = textH_all - lastLineSpaceHeight + lastLine.desc;\n                let rw = textH_all / Math.sin(rtPI) + textW_all_inner * Math.cos(rtPI);\n                let rh = textW_all_inner * Math.sin(rtPI), fixOneLineLeft = 0;\n                if (rt != 0) {\n                    if (splitLen == 1) {\n                        textW_all = textW_all_inner + 2 * (textH_all / Math.tan(rtPI));\n                        fixOneLineLeft = textH_all / Math.tan(rtPI);\n                    } else {\n                        textW_all = textW_all_inner + textH_all / Math.tan(rtPI);\n                    }\n                    textContent.textWidthAll = rw;\n                    textContent.textHeightAll = rh;\n                } else {\n                    textContent.textWidthAll = textW_all;\n                    textContent.textHeightAll = textH_all;\n                }\n                if (isMode == 'onlyWidth') {\n                    // console.log(\"plainWrap\", textContent,cell, option);\n                    return textContent;\n                }\n                if (rt != 0 && isRotateUp == '1') {\n                    ctx.textAlign = 'end';\n                    for (let i = 0; i < splitLen; i++) {\n                        let splitLists = text_all_split[i];\n                        if (splitLists == null) {\n                            continue;\n                        }\n                        let size = split_all_size[i];\n                        cumColumnWidth = 0;\n                        for (let c = splitLists.length - 1; c >= 0; c--) {\n                            let wordGroup = splitLists[c];\n                            let left, top;\n                            if (rt != 0) {\n                                //rotate\n                                let x, y = cumWordHeight + size.asc;\n                                x = cumWordHeight / Math.tan(rtPI) - cumColumnWidth + textW_all_inner;\n                                if (horizonAlign == '0') {\n                                    //center\n                                    let sh = textH_all / Math.sin(rtPI);\n                                    if (verticalAlign == '0') {\n                                        //mid\n                                        left = x + cellWidth / 2 - textW_all / 2 + lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y + cellHeight / 2 - textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '1') {\n                                        //top\n                                        left = x + cellWidth / 2 - textW_all / 2;\n                                        top = y - (textH_all / 2 - rh / 2);\n                                    } else if (verticalAlign == '2') {\n                                        //bottom\n                                        left = x + cellWidth / 2 - textW_all / 2 + lastLineSpaceHeight * Math.cos(rtPI);\n                                        top = y + cellHeight - rh / 2 - textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI);\n                                    }\n                                } else if (horizonAlign == '1') {\n                                    //left\n                                    if (verticalAlign == '0') {\n                                        //mid\n                                        left = x - rh * Math.sin(rtPI) / 2 + lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y + cellHeight / 2 + rh * Math.cos(rtPI) / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '1') {\n                                        //top\n                                        left = x - rh * Math.sin(rtPI);\n                                        top = y + rh * Math.cos(rtPI);\n                                    } else if (verticalAlign == '2') {\n                                        //bottom\n                                        left = x + lastLineSpaceHeight * Math.cos(rtPI);\n                                        top = y + cellHeight - lastLineSpaceHeight * Math.cos(rtPI);\n                                    }\n                                } else if (horizonAlign == '2') {\n                                    //right\n                                    if (verticalAlign == '0') {\n                                        //mid\n                                        left = x + cellWidth - rw / 2 - (textW_all_inner / 2 + textH_all / 2 / Math.tan(rtPI)) + lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y + cellHeight / 2 - textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '1') {\n                                        //top fixOneLineLeft\n                                        left = x + cellWidth - textW_all + fixOneLineLeft;\n                                        top = y - textH_all;\n                                    } else if (verticalAlign == '2') {\n                                        //bottom\n                                        left = x + cellWidth - rw * Math.cos(rtPI) + lastLineSpaceHeight * Math.cos(rtPI);\n                                        top = y + cellHeight - rw * Math.sin(rtPI) - lastLineSpaceHeight * Math.cos(rtPI);\n                                    }\n                                }\n                            }\n                            wordGroup.left = left;\n                            wordGroup.top = top;    // console.log(left, top,  cumWordHeight, size.height);\n                            // console.log(left, top,  cumWordHeight, size.height);\n                            drawLineInfo(wordGroup, cancelLine, underLine, {\n                                width: wordGroup.width,\n                                height: wordGroup.height,\n                                left: left - wordGroup.width,\n                                top: top,\n                                asc: size.asc,\n                                desc: size.desc,\n                                fs: wordGroup.fs\n                            });\n                            textContent.values.push(wordGroup);\n                            cumColumnWidth += wordGroup.width;\n                        }\n                        cumWordHeight += size.height;\n                    }\n                } else {\n                    for (let i = 0; i < splitLen; i++) {\n                        let splitLists = text_all_split[i];\n                        if (splitLists == null) {\n                            continue;\n                        }\n                        let size = split_all_size[i];\n                        cumColumnWidth = 0;\n                        for (let c = 0; c < splitLists.length; c++) {\n                            let wordGroup = splitLists[c];\n                            let left, top;\n                            if (rt != 0) {\n                                //rotate\n                                let x, y = cumWordHeight + size.asc;\n                                x = (textH_all - cumWordHeight) / Math.tan(rtPI) + cumColumnWidth;\n                                if (horizonAlign == '0') {\n                                    //center\n                                    let sh = textH_all / Math.sin(rtPI);\n                                    if (verticalAlign == '0') {\n                                        //mid\n                                        left = x + cellWidth / 2 - textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y + cellHeight / 2 - textH_all / 2 + lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '1') {\n                                        //top\n                                        left = x + cellWidth / 2 - textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y - (textH_all / 2 - rh / 2) + lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '2') {\n                                        //bottom\n                                        left = x + cellWidth / 2 - textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI);\n                                        top = y + cellHeight - rh / 2 - textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI);\n                                    }\n                                } else if (horizonAlign == '1') {\n                                    //left\n                                    if (verticalAlign == '0') {\n                                        //mid\n                                        left = x - rh * Math.sin(rtPI) / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y - textH_all + cellHeight / 2 - rh * Math.cos(rtPI) / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '1') {\n                                        //top\n                                        left = x;\n                                        top = y - textH_all;\n                                    } else if (verticalAlign == '2') {\n                                        //bottom\n                                        left = x - rh * Math.sin(rtPI) - lastLineSpaceHeight * Math.cos(rtPI);\n                                        top = y - textH_all + cellHeight - rh * Math.cos(rtPI) - lastLineSpaceHeight * Math.cos(rtPI);\n                                    }\n                                } else if (horizonAlign == '2') {\n                                    //right\n                                    if (verticalAlign == '0') {\n                                        //mid\n                                        left = x + cellWidth - rw / 2 - textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                        top = y + cellHeight / 2 - textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;\n                                    } else if (verticalAlign == '1') {\n                                        //top fixOneLineLeft\n                                        left = x + cellWidth - rw * Math.cos(rtPI);\n                                        top = y + rh * Math.cos(rtPI);\n                                    } else if (verticalAlign == '2') {\n                                        //bottom\n                                        left = x + cellWidth - textW_all - lastLineSpaceHeight * Math.cos(rtPI) + fixOneLineLeft;\n                                        top = y + cellHeight - lastLineSpaceHeight * Math.cos(rtPI);\n                                    }\n                                }\n                                drawLineInfo(wordGroup, cancelLine, underLine, {\n                                    width: wordGroup.width,\n                                    height: wordGroup.height,\n                                    left: left,\n                                    top: top,\n                                    asc: size.asc,\n                                    desc: size.desc,\n                                    fs: wordGroup.fs\n                                });\n                            } else {\n                                //plain\n                                left = space_width + cumColumnWidth;\n                                if (horizonAlign == '0') {\n                                    //+ space_width*textH_all_ColumnHeight.length\n                                    left = cellWidth / 2 + cumColumnWidth - size.width / 2;\n                                } else if (horizonAlign == '2') {\n                                    left = cellWidth + cumColumnWidth - size.width;\n                                }\n                                top = cellHeight - space_height + cumWordHeight + size.asc - textH_all;\n                                if (verticalAlign == '0') {\n                                    top = cellHeight / 2 + cumWordHeight - textH_all / 2 + size.asc;\n                                } else if (verticalAlign == '1') {\n                                    top = space_height + cumWordHeight + size.asc;\n                                }\n                                drawLineInfo(wordGroup, cancelLine, underLine, {\n                                    width: wordGroup.width,\n                                    height: wordGroup.height,\n                                    left: left,\n                                    top: top,\n                                    asc: size.asc,\n                                    desc: size.desc,\n                                    fs: wordGroup.fs\n                                });\n                            }\n                            wordGroup.left = left;\n                            wordGroup.top = top;\n                            textContent.values.push(wordGroup);\n                            cumColumnWidth += wordGroup.width;\n                        }\n                        cumWordHeight += size.height;\n                    }\n                }\n                textContent.type = 'plainWrap';\n                if (rt != 0) {\n                    // let leftCenter = (textW_all + textH_all/Math.tan(rt*Math.PI/180))/2;\n                    // let topCenter = textH_all/2;\n                    // if(isRotateUp==\"1\"){\n                    //     textContent.textLeftAll += leftCenter;\n                    //     textContent.textTopAll += topCenter;\n                    // }\n                    // else {\n                    //     textContent.textLeftAll += leftCenter;\n                    //     textContent.textTopAll -= topCenter;\n                    // }\n                    if (horizonAlign == '0') {\n                        //center\n                        if (verticalAlign == '0') {\n                            //mid\n                            textContent.textLeftAll = cellWidth / 2;\n                            textContent.textTopAll = cellHeight / 2;\n                        } else if (verticalAlign == '1') {\n                            //top\n                            textContent.textLeftAll = cellWidth / 2;\n                            textContent.textTopAll = rh / 2;\n                        } else if (verticalAlign == '2') {\n                            //bottom\n                            textContent.textLeftAll = cellWidth / 2;\n                            textContent.textTopAll = cellHeight - rh / 2;\n                        }\n                    } else if (horizonAlign == '1') {\n                        //left\n                        if (verticalAlign == '0') {\n                            //mid\n                            textContent.textLeftAll = 0;\n                            textContent.textTopAll = cellHeight / 2;\n                        } else if (verticalAlign == '1') {\n                            //top\n                            textContent.textLeftAll = 0;\n                            textContent.textTopAll = 0;\n                        } else if (verticalAlign == '2') {\n                            //bottom\n                            textContent.textLeftAll = 0;\n                            textContent.textTopAll = cellHeight;\n                        }\n                    } else if (horizonAlign == '2') {\n                        //right\n                        if (verticalAlign == '0') {\n                            //mid\n                            textContent.textLeftAll = cellWidth - rw / 2;\n                            textContent.textTopAll = cellHeight / 2;\n                        } else if (verticalAlign == '1') {\n                            //top\n                            textContent.textLeftAll = cellWidth;\n                            textContent.textTopAll = 0;\n                        } else if (verticalAlign == '2') {\n                            //bottom\n                            textContent.textLeftAll = cellWidth;\n                            textContent.textTopAll = cellHeight;\n                        }\n                    }\n                }    // else{\n                     //     textContent.textWidthAll = textW_all;\n                     //     textContent.textHeightAll = textH_all;\n                     // }\n            } else\n                // else{\n                //     textContent.textWidthAll = textW_all;\n                //     textContent.textHeightAll = textH_all;\n                // }\n                {\n                    let measureText = getMeasureText(value, ctx);\n                    let textWidth = measureText.width;\n                    let textHeight = measureText.actualBoundingBoxDescent + measureText.actualBoundingBoxAscent;\n                    textContent.rotate = rt;\n                    rt = Math.abs(rt);\n                    let rtPI = rt * Math.PI / 180;\n                    let textWidthAll = textWidth * Math.cos(rtPI) + textHeight * Math.sin(rtPI);    //consider text box wdith and line height\n                    //consider text box wdith and line height\n                    let textHeightAll = textWidth * Math.sin(rtPI) + textHeight * Math.cos(rtPI);    //consider text box wdith and line height\n                    //consider text box wdith and line height\n                    if (rt != 0) {\n                        textContent.textHeightAll = textHeightAll;\n                    } else {\n                        textContent.textHeightAll = textHeightAll + textHeight / 2 - measureText.actualBoundingBoxDescent - space_height;\n                    }\n                    textContent.textWidthAll = textWidthAll;    // console.log(textContent.textWidthAll , textContent.textHeightAll);\n                    // console.log(textContent.textWidthAll , textContent.textHeightAll);\n                    if (isMode == 'onlyWidth') {\n                        // console.log(\"plain\", textContent,cell, option);\n                        return textContent;\n                    }\n                    let width = textWidthAll, height = textHeightAll;\n                    let left = space_width + textHeight * Math.sin(rtPI) * isRotateUp;    //默认为1，左对齐\n                    //默认为1，左对齐\n                    if (horizonAlign == '0') {\n                        //居中对齐\n                        left = cellWidth / 2 - width / 2 + textHeight * Math.sin(rtPI) * isRotateUp;\n                    } else if (horizonAlign == '2') {\n                        //右对齐\n                        left = cellWidth - space_width - width + textHeight * Math.sin(rtPI) * isRotateUp;\n                    }\n                    let top = cellHeight - space_height - height + measureText.actualBoundingBoxAscent * Math.cos(rtPI) + textWidth * Math.sin(rtPI) * isRotateUp;    //默认为2，下对齐\n                    //默认为2，下对齐\n                    if (verticalAlign == '0') {\n                        //居中对齐\n                        top = cellHeight / 2 - height / 2 + measureText.actualBoundingBoxAscent * Math.cos(rtPI) + textWidth * Math.sin(rtPI) * isRotateUp;\n                    } else if (verticalAlign == '1') {\n                        //上对齐\n                        top = space_height + measureText.actualBoundingBoxAscent * Math.cos(rtPI) + textWidth * Math.sin(rtPI) * isRotateUp;\n                    }\n                    textContent.type = 'plain';\n                    let wordGroup = {\n                        content: value,\n                        style: fontset,\n                        width: width,\n                        height: height,\n                        left: left,\n                        top: top\n                    };\n                    drawLineInfo(wordGroup, cancelLine, underLine, {\n                        width: textWidth,\n                        height: textHeight,\n                        left: left,\n                        top: top,\n                        asc: measureText.actualBoundingBoxAscent,\n                        desc: measureText.actualBoundingBoxDescent,\n                        fs: fontSize\n                    });\n                    textContent.values.push(wordGroup);\n                    textContent.textLeftAll = left;\n                    textContent.textTopAll = top;\n                    textContent.asc = measureText.actualBoundingBoxAscent;\n                    textContent.desc = measureText.actualBoundingBoxDescent;    // console.log(\"plain\",left,top);\n                }\n        }\n        // console.log(\"plain\",left,top);\n        return textContent;\n    }\n    function drawLineInfo(wordGroup, cancelLine, underLine, option) {\n        let left = option.left, top = option.top, width = option.width, height = option.height, asc = option.asc, desc = option.desc, fs = option.fs;\n        if (wordGroup.wrap === true) {\n            return;\n        }\n        if (wordGroup.inline == true && wordGroup.style != null) {\n            cancelLine = wordGroup.style.cl;\n            underLine = wordGroup.style.un;\n        }\n        if (cancelLine != '0') {\n            wordGroup.cancelLine = {};\n            wordGroup.cancelLine.startX = left;\n            wordGroup.cancelLine.startY = top - asc / 2 + 1;\n            wordGroup.cancelLine.endX = left + width;\n            wordGroup.cancelLine.endY = top - asc / 2 + 1;\n            wordGroup.cancelLine.fs = fs;\n        }\n        if (underLine != '0') {\n            wordGroup.underLine = [];\n            if (underLine == '1' || underLine == '2') {\n                let item = {};\n                item.startX = left;\n                item.startY = top;\n                item.endX = left + width;\n                item.endY = top;\n                item.fs = fs;\n                wordGroup.underLine.push(item);\n            }\n            if (underLine == '2') {\n                let item = {};\n                item.startX = left;\n                item.startY = top + desc;\n                item.endX = left + width;\n                item.endY = top + desc;\n                item.fs = fs;\n                wordGroup.underLine.push(item);\n            }\n            if (underLine == '3' || underLine == '4') {\n                let item = {};\n                item.startX = left;\n                item.startY = top + desc;\n                item.endX = left + width;\n                item.endY = top + desc;\n                item.fs = fs;\n                wordGroup.underLine.push(item);\n            }\n            if (underLine == '4') {\n                let item = {};\n                item.startX = left;\n                item.startY = top + desc + 2;\n                item.endX = left + width;\n                item.endY = top + desc + 2;\n                item.fs = fs;\n                wordGroup.underLine.push(item);\n            }\n        }\n    }\n    return {\n        rowlenByRange,\n        computeRowlenArr,\n        getCellTextSplitArr,\n        getMeasureText,\n        getCellTextInfo\n    };\n});"]}