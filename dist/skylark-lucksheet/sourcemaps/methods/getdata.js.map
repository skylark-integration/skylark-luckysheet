{"version":3,"sources":["methods/getdata.js"],"names":["define","m_util","m_get","m_dynamicArray","locale","Store","getObjType","rgbTohex","textTrim","convertCssToStyleList","getFontStyleByCell","getSheetIndex","dynamicArrayCompute","getcellvalue","r","c","data","type","d_value","flowdata","map","col","i","row","retv","ct","t","m","undefined","getOrigincell","getSheetByIndex","isInlineStringCT","s","length","getGridData","d","ret","push","v","getdatabyselection","range","sheetIndex","luckysheet_select_save","cfg","currentSheetIndex","luckysheetfile","deepCopyFlowData","config","getdatabyselectionD","dynamicArray_compute","value","getdatabyselectionNoCopy","datagridgrowth","addr","addc","iscallback","dataClen","coladd","rowadd","concat","saveParam","k","getcellFormula","cell","f","getRealCellValue","getInlineStringNoStyle","strings","strObj","getInlineStringStyle"],"mappings":";;;;;;;AAAAA,QACI,gBACA,QACA,iBACA,mBACA,YACD,SAAUC,EAAOC,EAAQC,EAAgBC,EAAQC,GAChD,aACA,MAAMC,WAACA,EAAUC,SAAEA,EAAQC,SAACA,EAAQC,sBAACA,EAAqBC,mBAACA,GAAsBT,GAC3EU,cAACA,GAAiBT,GAClBU,oBAACA,GAAuBT,EAuF9B,SAASU,EAAaC,EAAGC,EAAGC,EAAMC,GAO9B,IAAIC,EACJ,GAPY,MAARD,IACAA,EAAO,KAEC,MAARD,IACAA,EAAOX,EAAMc,UAGR,MAALL,GAAkB,MAALC,EACbG,EAAUF,EAAKF,GAAGC,QACf,GAAS,MAALD,EACPI,EAAUF,EAAKF,OACZ,CAAA,GAAS,MAALC,EAQP,OAAOC,EAFPE,EALcF,EAAK,GAAGI,IAAI,SAAUC,EAAKC,GACrC,OAAON,EAAKI,IAAI,SAAUG,GACtB,OAAOA,EAAID,OAGDP,GAItB,IAAIS,EAAON,EAcX,MAb2B,UAAvBZ,EAAWY,KACXM,EAAON,EAAQD,GACH,KAARA,GAAuB,MAARO,IAEA,KAARP,EACPO,EAAON,EAAW,EACXA,GAAWA,EAAQO,IAAsB,KAAhBP,EAAQO,GAAGC,IAC3CF,EAAON,EAAQS,UAGXC,GAARJ,IACAA,EAAO,MAEJA,EAqDX,SAASK,EAAcf,EAAGC,EAAGO,GACzB,GAAS,MAALR,GAAkB,MAALC,EACb,OAEJ,IAAIC,EACJ,GAAS,MAALM,EACAN,EAAOX,EAAMc,aACV,CAEHH,EADYX,EAAMyB,gBAAgBR,GACrBN,KAEjB,OAAKA,GAASA,EAAKF,IAAOE,EAAKF,GAAGC,GAG3BC,EAAKF,GAAGC,QAHf,EAsEJ,SAASgB,EAAiBN,GAEtB,OADiB,MAANA,GAAsB,aAARA,EAAGC,GAA4B,MAARD,EAAGO,GAAaP,EAAGO,EAAEC,OAAS,EAIlF,OACIC,YAvBJ,SAAqBC,GACjB,IAAIC,KACJ,IAAK,IAAItB,EAAI,EAAGA,EAAIqB,EAAEF,OAAQnB,IAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAIoB,EAAE,GAAGF,OAAQlB,IACd,MAAXoB,EAAErB,GAAGC,IAGTqB,EAAIC,MACAvB,EAAGA,EACHC,EAAGA,EACHuB,EAAGH,EAAErB,GAAGC,KAIpB,OAAOqB,GAWPG,mBAvQJ,SAA4BC,EAAOC,GAI/B,GAHa,MAATD,IACAA,EAAQnC,EAAMqC,uBAAuB,IAErB,MAAhBF,EAAW,KAAoC,GAAvBA,EAAW,IAAEP,OACrC,SAGJ,IAAIE,EAAGQ,EACW,MAAdF,GAAsBA,GAAcpC,EAAMuC,mBAC1CT,EAAI9B,EAAMwC,eAAelC,EAAc8B,IAAmB,KAC1DE,EAAMtC,EAAMwC,eAAelC,EAAc8B,IAAqB,SAE9DN,EAAI9B,EAAMyC,iBAAiBzC,EAAMc,UACjCwB,EAAMtC,EAAM0C,QAEhB,IAAI/B,KACJ,IAAK,IAAIF,EAAI0B,EAAW,IAAE,GAAI1B,GAAK0B,EAAW,IAAE,GAAI1B,IAAK,CACrD,GAAY,MAARqB,EAAErB,GACF,SAEJ,GAAwB,MAApB6B,EAAe,WAAoC,MAAvBA,EAAe,UAAE7B,GAC7C,SAEJ,IAAIS,KACJ,IAAK,IAAIR,EAAIyB,EAAc,OAAE,GAAIzB,GAAKyB,EAAc,OAAE,GAAIzB,IACtDQ,EAAIc,KAAKF,EAAErB,GAAGC,IAElBC,EAAKqB,KAAKd,GAEd,OAAOP,GA0OPgC,oBAxOJ,SAA6Bb,EAAGK,GAC5B,GAAa,MAATA,GAAiC,MAAhBA,EAAW,KAAoC,GAAvBA,EAAW,IAAEP,OACtD,SAEJ,IAAIgB,EAAuBrC,EAAoBP,EAAMwC,eAAelC,EAAcN,EAAMuC,oBAAkC,cACtH5B,KACJ,GAAS,MAALmB,EACA,OAAOnB,EAEX,IAAK,IAAIF,EAAI0B,EAAW,IAAE,GAAI1B,GAAK0B,EAAW,IAAE,GAAI1B,IAAK,CACrD,GAAY,MAARqB,EAAErB,GACF,SAOJ,IAAIS,KACJ,IAAK,IAAIR,EAAIyB,EAAc,OAAE,GAAIzB,GAAKyB,EAAc,OAAE,GAAIzB,IAAK,CAC3D,IAAImC,EAEAA,EADApC,EAAI,IAAMC,KAAKkC,EACPA,EAAqBnC,EAAI,IAAMC,GAE/BoB,EAAErB,GAAGC,GAEjBQ,EAAIc,KAAKa,GAEblC,EAAKqB,KAAKd,GAEd,OAAOP,GA2MPmC,yBAzMJ,SAAkCX,GAC9B,GAAa,MAATA,GAAiC,MAAhBA,EAAW,KAAoC,GAAvBA,EAAW,IAAEP,OACtD,SAEJ,IAAIjB,KACJ,IAAK,IAAIF,EAAI0B,EAAW,IAAE,GAAI1B,GAAK0B,EAAW,IAAE,GAAI1B,IAAK,CACrD,IAAIS,KACJ,GAAiC,MAA7BlB,EAAM0C,OAAkB,WAA6C,MAAhC1C,EAAM0C,OAAkB,UAAEjC,GAAnE,CAGA,IAAK,IAAIC,EAAIyB,EAAc,OAAE,GAAIzB,GAAKyB,EAAc,OAAE,GAAIzB,IAAK,CAC3D,IAAImC,EAAQ,GACa,MAArB7C,EAAMc,SAASL,IAAsC,MAAxBT,EAAMc,SAASL,GAAGC,KAC/CmC,EAAQ7C,EAAMc,SAASL,GAAGC,IAE9BQ,EAAIc,KAAKa,GAEblC,EAAKqB,KAAKd,IAEd,OAAOP,GAuLPH,aAAcA,EACduC,eAhJJ,SAAwBpC,EAAMqC,EAAMC,EAAMC,GACtC,GAAIF,GAAQ,GAAKC,GAAQ,EACrB,OAAOtC,EAEPqC,GAAQ,IACRA,EAAO,GAEPC,GAAQ,IACRA,EAAO,GAEX,IAAIE,EAAW,EACI,GAAfxC,EAAKiB,QACLjB,KACAwC,EAAW,GAEXA,EAAWxC,EAAK,GAAGiB,OAEvB,IAAIwB,KAEJ,IAAK,IAAI1C,EAAI,EAAGA,EAAIuC,EAAMvC,IACtB0C,EAAOpB,KAAK,MAEhB,IAAIqB,KAEJ,IAAK,IAAI5C,EAAI,EAAGA,EAAI0C,EAAWF,EAAMxC,IACjC4C,EAAOrB,KAAK,MAEhB,IAAK,IAAIvB,EAAI,EAAGA,EAAIE,EAAKiB,OAAQnB,IAC7BE,EAAKF,MAAQ6C,OAAO3C,EAAKF,GAAG6C,OAAOF,IAEvC,IAAK,IAAI3C,EAAI,EAAGA,EAAIuC,EAAMvC,IACtBE,EAAKqB,QAAQsB,OAAOD,IAMxB,OAJMH,IACFlD,EAAMuD,UAAU,MAAOvD,EAAMuC,kBAAmB5B,EAAKiB,QAAU4B,EAAK,QACpExD,EAAMuD,UAAU,MAAOvD,EAAMuC,kBAAmB5B,EAAK,GAAGiB,QAAU4B,EAAK,YAEpE7C,GA4GP8C,eA1GJ,SAAwBhD,EAAGC,EAAGO,EAAGN,GAC7B,IAAI+C,EAMJ,OAAY,OAJRA,EADQ,MAAR/C,EACOA,EAAKF,GAAGC,GAERc,EAAcf,EAAGC,EAAGO,IAGpB,KAEJyC,EAAKC,GAiGZnC,cAAeA,EACfoC,iBAhFJ,SAA0BnD,EAAGC,GACzB,IAAImC,EAAQrC,EAAaC,EAAGC,EAAG,KAAM,KACrC,GAAa,MAATmC,GAEa,OADbA,EAAQrC,EAAaC,EAAGC,IACL,CACf,IAAIU,EAAKZ,EAAaC,EAAGC,EAAG,KAAM,MAC9BgB,EAAiBN,KACjByB,EAAQzB,EAAGO,GAIvB,OAAOkB,GAsEPgB,uBApEJ,SAAgCpD,EAAGC,GAC/B,IAAIU,EAAKZ,EAAaC,EAAGC,EAAG,KAAM,MAClC,GAAIgB,EAAiBN,GAAK,CACtB,IAAI0C,EAAU1C,EAAGO,EAAGkB,EAAQ,GAC5B,IAAK,IAAI5B,EAAI,EAAGA,EAAI6C,EAAQlC,OAAQX,IAAK,CACrC,IAAI8C,EAASD,EAAQ7C,GACL,MAAZ8C,EAAO9B,IACPY,GAASkB,EAAO9B,GAGxB,OAAOY,EAEX,MAAO,IAyDPmB,qBAvDJ,SAA8BvD,EAAGC,EAAGC,GAChC,IAAIS,EAAKZ,EAAaC,EAAGC,EAAGC,EAAM,MAKlC,GAJY,MAARA,IACAA,EAAOX,EAAMc,UAENH,EAAKF,GAAGC,GACfgB,EAAiBN,GAAK,CACtB,IAAI0C,EAAU1C,EAAGO,EAAGkB,EAAQ,GAC5B,IAAK,IAAI5B,EAAI,EAAGA,EAAI6C,EAAQlC,OAAQX,IAAK,CACrC,IAAI8C,EAASD,EAAQ7C,GACL,MAAZ8C,EAAO9B,IAEPY,GAAS,gBAAkB5B,EAAI,YADnBZ,EAAmB0D,GACsB,KAAOA,EAAO9B,EAAI,WAG/E,OAAOY,EAEX,MAAO,IAuCPxC,mBAAoBA,EACpBF,SAAUA,EACVuB,iBAAAA","file":"../../methods/getdata.js","sourcesContent":["define([\n    '../utils/util',\n    './get',\n    './dynamicArray',\n    '../locale/locale',\n    '../store'\n], function (m_util,m_get,  m_dynamicArray, locale, Store) {\n    'use strict';\n    const {getObjType, rgbTohex,textTrim,convertCssToStyleList,getFontStyleByCell} = m_util;\n    const {getSheetIndex} = m_get;\n    const {dynamicArrayCompute} = m_dynamicArray;\n\n    function getdatabyselection(range, sheetIndex) {\n        if (range == null) {\n            range = Store.luckysheet_select_save[0];\n        }\n        if (range['row'] == null || range['row'].length == 0) {\n            return [];\n        }    //取数据\n        //取数据\n        let d, cfg;\n        if (sheetIndex != null && sheetIndex != Store.currentSheetIndex) {\n            d = Store.luckysheetfile[getSheetIndex(sheetIndex)]['data'];\n            cfg = Store.luckysheetfile[getSheetIndex(sheetIndex)]['config'];\n        } else {\n            d = Store.deepCopyFlowData(Store.flowdata);\n            cfg = Store.config;\n        }\n        let data = [];\n        for (let r = range['row'][0]; r <= range['row'][1]; r++) {\n            if (d[r] == null) {\n                continue;\n            }\n            if (cfg['rowhidden'] != null && cfg['rowhidden'][r] != null) {\n                continue;\n            }\n            let row = [];\n            for (let c = range['column'][0]; c <= range['column'][1]; c++) {\n                row.push(d[r][c]);\n            }\n            data.push(row);\n        }\n        return data;\n    }\n    function getdatabyselectionD(d, range) {\n        if (range == null || range['row'] == null || range['row'].length == 0) {\n            return [];\n        }\n        let dynamicArray_compute = dynamicArrayCompute(Store.luckysheetfile[getSheetIndex(Store.currentSheetIndex)]['dynamicArray']);\n        let data = [];\n        if (d == null) {\n            return data;\n        }\n        for (let r = range['row'][0]; r <= range['row'][1]; r++) {\n            if (d[r] == null) {\n                continue;\n            }    // if (Store.config[\"rowhidden\"] != null && Store.config[\"rowhidden\"][r] != null) {\n                 //     continue;\n                 // }\n            // if (Store.config[\"rowhidden\"] != null && Store.config[\"rowhidden\"][r] != null) {\n            //     continue;\n            // }\n            let row = [];\n            for (let c = range['column'][0]; c <= range['column'][1]; c++) {\n                let value;\n                if (r + '_' + c in dynamicArray_compute) {\n                    value = dynamicArray_compute[r + '_' + c];\n                } else {\n                    value = d[r][c];\n                }\n                row.push(value);\n            }\n            data.push(row);\n        }\n        return data;\n    }\n    function getdatabyselectionNoCopy(range) {\n        if (range == null || range['row'] == null || range['row'].length == 0) {\n            return [];\n        }\n        let data = [];\n        for (let r = range['row'][0]; r <= range['row'][1]; r++) {\n            let row = [];\n            if (Store.config['rowhidden'] != null && Store.config['rowhidden'][r] != null) {\n                continue;\n            }\n            for (let c = range['column'][0]; c <= range['column'][1]; c++) {\n                let value = '';\n                if (Store.flowdata[r] != null && Store.flowdata[r][c] != null) {\n                    value = Store.flowdata[r][c];\n                }\n                row.push(value);\n            }\n            data.push(row);\n        }\n        return data;\n    }\n    function getcellvalue(r, c, data, type) {\n        if (type == null) {\n            type = 'v';\n        }\n        if (data == null) {\n            data = Store.flowdata;\n        }\n        let d_value;\n        if (r != null && c != null) {\n            d_value = data[r][c];\n        } else if (r != null) {\n            d_value = data[r];\n        } else if (c != null) {\n            let newData = data[0].map(function (col, i) {\n                return data.map(function (row) {\n                    return row[i];\n                });\n            });\n            d_value = newData[c];\n        } else {\n            return data;\n        }\n        let retv = d_value;\n        if (getObjType(d_value) == 'object') {\n            retv = d_value[type];\n            if (type == 'f' && retv != null) {\n                ///retv = formula.functionHTMLGenerate(retv); //TODO:lwf\n            } else if (type == 'f') {\n                retv = d_value['v'];\n            } else if (d_value && d_value.ct && d_value.ct.t == 'd') {\n                retv = d_value.m;\n            }\n        }\n        if (retv == undefined) {\n            retv = null;\n        }\n        return retv;\n    }\n    function datagridgrowth(data, addr, addc, iscallback) {\n        if (addr <= 0 && addc <= 0) {\n            return data;\n        }\n        if (addr <= 0) {\n            addr = 0;\n        }\n        if (addc <= 0) {\n            addc = 0;\n        }\n        let dataClen = 0;\n        if (data.length == 0) {\n            data = [];\n            dataClen = 0;\n        } else {\n            dataClen = data[0].length;\n        }\n        let coladd = [];    //需要额外增加的空列\n        //需要额外增加的空列\n        for (let c = 0; c < addc; c++) {\n            coladd.push(null);\n        }\n        let rowadd = [];    //完整的一个空行\n        //完整的一个空行\n        for (let r = 0; r < dataClen + addc; r++) {\n            rowadd.push(null);\n        }\n        for (let r = 0; r < data.length; r++) {\n            data[r] = [].concat(data[r].concat(coladd));\n        }\n        for (let r = 0; r < addr; r++) {\n            data.push([].concat(rowadd));\n        }\n        if (!!iscallback) {\n            Store.saveParam('all', Store.currentSheetIndex, data.length, { 'k': 'row' });\n            Store.saveParam('all', Store.currentSheetIndex, data[0].length, { 'k': 'column' });\n        }\n        return data;\n    }\n    function getcellFormula(r, c, i, data) {\n        let cell;\n        if (data != null) {\n            cell = data[r][c];\n        } else {\n            cell = getOrigincell(r, c, i);\n        }\n        if (cell == null) {\n            return null;\n        }\n        return cell.f;\n    }\n    function getOrigincell(r, c, i) {\n        if (r == null || c == null) {\n            return;\n        }\n        let data;\n        if (i == null) {\n            data = Store.flowdata;\n        } else {\n            let sheet = Store.getSheetByIndex(i);\n            data = sheet.data;\n        }\n        if (!data || !data[r] || !data[r][c]) {\n            return;\n        }\n        return data[r][c];\n    }\n    function getRealCellValue(r, c) {\n        let value = getcellvalue(r, c, null, 'm');\n        if (value == null) {\n            value = getcellvalue(r, c);\n            if (value == null) {\n                let ct = getcellvalue(r, c, null, 'ct');\n                if (isInlineStringCT(ct)) {\n                    value = ct.s;\n                }\n            }\n        }\n        return value;\n    }\n    function getInlineStringNoStyle(r, c) {\n        let ct = getcellvalue(r, c, null, 'ct');\n        if (isInlineStringCT(ct)) {\n            let strings = ct.s, value = '';\n            for (let i = 0; i < strings.length; i++) {\n                let strObj = strings[i];\n                if (strObj.v != null) {\n                    value += strObj.v;\n                }\n            }\n            return value;\n        }\n        return '';\n    }\n    function getInlineStringStyle(r, c, data) {\n        let ct = getcellvalue(r, c, data, 'ct');\n        if (data == null) {\n            data = Store.flowdata;\n        }\n        let cell = data[r][c];\n        if (isInlineStringCT(ct)) {\n            let strings = ct.s, value = '';\n            for (let i = 0; i < strings.length; i++) {\n                let strObj = strings[i];\n                if (strObj.v != null) {\n                    let style = getFontStyleByCell(strObj);\n                    value += \"<span index='\" + i + \"' style='\" + style + \"'>\" + strObj.v + '</span>';\n                }\n            }\n            return value;\n        }\n        return '';\n    }\n\n    // from controllers/sheetmanage\n    function getGridData(d) {\n        let ret = [];\n        for (let r = 0; r < d.length; r++) {\n            for (let c = 0; c < d[0].length; c++) {\n                if (d[r][c] == null) {\n                    continue;\n                }\n                ret.push({\n                    r: r,\n                    c: c,\n                    v: d[r][c]\n                });\n            }\n        }\n        return ret;\n    }\n\n    function isInlineStringCT(ct) {\n        let isIs = ct != null && ct.t == 'inlineStr' && ct.s != null && ct.s.length > 0;\n        return isIs;\n    }\n\n    return {\n        getGridData,\n        \n        getdatabyselection: getdatabyselection,\n        getdatabyselectionD: getdatabyselectionD,\n        getdatabyselectionNoCopy: getdatabyselectionNoCopy,\n        getcellvalue: getcellvalue,\n        datagridgrowth: datagridgrowth,\n        getcellFormula: getcellFormula,\n        getOrigincell: getOrigincell,\n        getRealCellValue: getRealCellValue,\n        getInlineStringNoStyle: getInlineStringNoStyle,\n        getInlineStringStyle: getInlineStringStyle,\n        getFontStyleByCell: getFontStyleByCell,\n        textTrim: textTrim,\n        isInlineStringCT\n    };\n});"]}